<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Beej's Guide to C Programming</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!-- BG custom styling -->
  <style type="text/css">
  /* Fix for line numbers not visible */
  pre.numberSource code > span {
      left: -1em;
  }
  pre.numberSource {
      margin-left: initial;
  }

  /* Put some space after the section numbers */
  span.toc-section-number::after {
      content: "\a0\a0\a0";  /* non-breaking whitespace */
  }

  /* Hide underlines on code number links */
  pre > code.sourceCode > span > a:first-child::before {
      text-decoration: none;
  }

  /* Color the source blocks */
  div.sourceCode {
      background-color: #f0f0f0;
  }

  /* Fix iOS big text rendering issue */
  pre > code.sourceCode > span {
      display: initial;
  }


  /* Color the inline code */
  code:not(.sourceCode) {
      background: #f0f0f0;
      padding-left: 0.2em;
      padding-right: 0.2em;
      border-radius: 0.2em;
  }

  pre.sourceCode {
      border: 1px solid #ccc;
      padding: 0.5em;
      border-radius: 0.2em;
  }

  /* Keep code tags from wrapping in tables */
  tbody code {
      white-space: nowrap;
  }

  /* Prevent hyphenation and hyphen breaks in code*/
  code {
      word-break: keep-all;
  }

  td {
      vertical-align: top;
  }

  body {
      font-size: 12pt;
      max-width: 43em;
      font-family: sans-serif;
  }

  html {
      background: #f9f9f9;
  }

  figure > embed {
      max-width: 100%;
  }

  figure {
      text-align: center;
      margin-top: 2em;
      margin-bottom: 2em;
  }

  figcaption {
      font-size: 0.9em;
      font-style: italic;
      margin-top: 0.6em;
  }

  body {
      counter-reset: figure-counter-major;
      counter-reset: figure-counter-minor;
  }

  figure {
      counter-increment: figure-counter-minor;
  }

  figcaption::before {
      content: "Figure " counter(figure-counter-major) "." counter(figure-counter-minor) ": ";
  }

  blockquote {
      border-left: 2px solid #bbb;
      color: #444;
  }

  /* Contents */

  nav[role="doc-toc"] > ul > li {
    font-weight: bold;
    margin-top: 1.2em;
  }

  nav[role="doc-toc"] > ul > li:first {
    font-weight: bold;
    margin-top: initial;
  }

  nav[role="doc-toc"] > ul > li > ul {
    font-weight: normal;
    margin-top: 0.3em;
  }

  /*
  In multipage, we need to reset the figure counter to the chapter
  number. Luckily, this is in the <h1 data-number> attribute. Unluckily,
  there is no way to get this in a general way.

  This doesn't work:

    h1[data-number] {
      counter-set: figure-counter-major attr(data-number);
    }

  Nor this:

    h1[data-number] {
      --figure-counter-major-value: attr(data-number);
      counter-set: figure-counter-major var(--figure-counter-major-value);
    }

  So, dumbly, we have a bunch of rules for all these sections, up to the
  maximum possible section.

  Here's a program to generate them:

    for (let i = 1; i < 100; i++)
        console.log(`h1[data-number="${i}"]{counter-set:figure-counter-major ${i};counter-reset:figure-counter-minor;}`);

  Note to self: never write a book with more than 99 frickin' chapters.
  */

  h1[data-number="1"]{counter-set:figure-counter-major 1;counter-reset:figure-counter-minor;}
  h1[data-number="2"]{counter-set:figure-counter-major 2;counter-reset:figure-counter-minor;}
  h1[data-number="3"]{counter-set:figure-counter-major 3;counter-reset:figure-counter-minor;}
  h1[data-number="4"]{counter-set:figure-counter-major 4;counter-reset:figure-counter-minor;}
  h1[data-number="5"]{counter-set:figure-counter-major 5;counter-reset:figure-counter-minor;}
  h1[data-number="6"]{counter-set:figure-counter-major 6;counter-reset:figure-counter-minor;}
  h1[data-number="7"]{counter-set:figure-counter-major 7;counter-reset:figure-counter-minor;}
  h1[data-number="8"]{counter-set:figure-counter-major 8;counter-reset:figure-counter-minor;}
  h1[data-number="9"]{counter-set:figure-counter-major 9;counter-reset:figure-counter-minor;}
  h1[data-number="10"]{counter-set:figure-counter-major 10;counter-reset:figure-counter-minor;}
  h1[data-number="11"]{counter-set:figure-counter-major 11;counter-reset:figure-counter-minor;}
  h1[data-number="12"]{counter-set:figure-counter-major 12;counter-reset:figure-counter-minor;}
  h1[data-number="13"]{counter-set:figure-counter-major 13;counter-reset:figure-counter-minor;}
  h1[data-number="14"]{counter-set:figure-counter-major 14;counter-reset:figure-counter-minor;}
  h1[data-number="15"]{counter-set:figure-counter-major 15;counter-reset:figure-counter-minor;}
  h1[data-number="16"]{counter-set:figure-counter-major 16;counter-reset:figure-counter-minor;}
  h1[data-number="17"]{counter-set:figure-counter-major 17;counter-reset:figure-counter-minor;}
  h1[data-number="18"]{counter-set:figure-counter-major 18;counter-reset:figure-counter-minor;}
  h1[data-number="19"]{counter-set:figure-counter-major 19;counter-reset:figure-counter-minor;}
  h1[data-number="20"]{counter-set:figure-counter-major 20;counter-reset:figure-counter-minor;}
  h1[data-number="21"]{counter-set:figure-counter-major 21;counter-reset:figure-counter-minor;}
  h1[data-number="22"]{counter-set:figure-counter-major 22;counter-reset:figure-counter-minor;}
  h1[data-number="23"]{counter-set:figure-counter-major 23;counter-reset:figure-counter-minor;}
  h1[data-number="24"]{counter-set:figure-counter-major 24;counter-reset:figure-counter-minor;}
  h1[data-number="25"]{counter-set:figure-counter-major 25;counter-reset:figure-counter-minor;}
  h1[data-number="26"]{counter-set:figure-counter-major 26;counter-reset:figure-counter-minor;}
  h1[data-number="27"]{counter-set:figure-counter-major 27;counter-reset:figure-counter-minor;}
  h1[data-number="28"]{counter-set:figure-counter-major 28;counter-reset:figure-counter-minor;}
  h1[data-number="29"]{counter-set:figure-counter-major 29;counter-reset:figure-counter-minor;}
  h1[data-number="30"]{counter-set:figure-counter-major 30;counter-reset:figure-counter-minor;}
  h1[data-number="31"]{counter-set:figure-counter-major 31;counter-reset:figure-counter-minor;}
  h1[data-number="32"]{counter-set:figure-counter-major 32;counter-reset:figure-counter-minor;}
  h1[data-number="33"]{counter-set:figure-counter-major 33;counter-reset:figure-counter-minor;}
  h1[data-number="34"]{counter-set:figure-counter-major 34;counter-reset:figure-counter-minor;}
  h1[data-number="35"]{counter-set:figure-counter-major 35;counter-reset:figure-counter-minor;}
  h1[data-number="36"]{counter-set:figure-counter-major 36;counter-reset:figure-counter-minor;}
  h1[data-number="37"]{counter-set:figure-counter-major 37;counter-reset:figure-counter-minor;}
  h1[data-number="38"]{counter-set:figure-counter-major 38;counter-reset:figure-counter-minor;}
  h1[data-number="39"]{counter-set:figure-counter-major 39;counter-reset:figure-counter-minor;}
  h1[data-number="40"]{counter-set:figure-counter-major 40;counter-reset:figure-counter-minor;}
  h1[data-number="41"]{counter-set:figure-counter-major 41;counter-reset:figure-counter-minor;}
  h1[data-number="42"]{counter-set:figure-counter-major 42;counter-reset:figure-counter-minor;}
  h1[data-number="43"]{counter-set:figure-counter-major 43;counter-reset:figure-counter-minor;}
  h1[data-number="44"]{counter-set:figure-counter-major 44;counter-reset:figure-counter-minor;}
  h1[data-number="45"]{counter-set:figure-counter-major 45;counter-reset:figure-counter-minor;}
  h1[data-number="46"]{counter-set:figure-counter-major 46;counter-reset:figure-counter-minor;}
  h1[data-number="47"]{counter-set:figure-counter-major 47;counter-reset:figure-counter-minor;}
  h1[data-number="48"]{counter-set:figure-counter-major 48;counter-reset:figure-counter-minor;}
  h1[data-number="49"]{counter-set:figure-counter-major 49;counter-reset:figure-counter-minor;}
  h1[data-number="50"]{counter-set:figure-counter-major 50;counter-reset:figure-counter-minor;}
  h1[data-number="51"]{counter-set:figure-counter-major 51;counter-reset:figure-counter-minor;}
  h1[data-number="52"]{counter-set:figure-counter-major 52;counter-reset:figure-counter-minor;}
  h1[data-number="53"]{counter-set:figure-counter-major 53;counter-reset:figure-counter-minor;}
  h1[data-number="54"]{counter-set:figure-counter-major 54;counter-reset:figure-counter-minor;}
  h1[data-number="55"]{counter-set:figure-counter-major 55;counter-reset:figure-counter-minor;}
  h1[data-number="56"]{counter-set:figure-counter-major 56;counter-reset:figure-counter-minor;}
  h1[data-number="57"]{counter-set:figure-counter-major 57;counter-reset:figure-counter-minor;}
  h1[data-number="58"]{counter-set:figure-counter-major 58;counter-reset:figure-counter-minor;}
  h1[data-number="59"]{counter-set:figure-counter-major 59;counter-reset:figure-counter-minor;}
  h1[data-number="60"]{counter-set:figure-counter-major 60;counter-reset:figure-counter-minor;}
  h1[data-number="61"]{counter-set:figure-counter-major 61;counter-reset:figure-counter-minor;}
  h1[data-number="62"]{counter-set:figure-counter-major 62;counter-reset:figure-counter-minor;}
  h1[data-number="63"]{counter-set:figure-counter-major 63;counter-reset:figure-counter-minor;}
  h1[data-number="64"]{counter-set:figure-counter-major 64;counter-reset:figure-counter-minor;}
  h1[data-number="65"]{counter-set:figure-counter-major 65;counter-reset:figure-counter-minor;}
  h1[data-number="66"]{counter-set:figure-counter-major 66;counter-reset:figure-counter-minor;}
  h1[data-number="67"]{counter-set:figure-counter-major 67;counter-reset:figure-counter-minor;}
  h1[data-number="68"]{counter-set:figure-counter-major 68;counter-reset:figure-counter-minor;}
  h1[data-number="69"]{counter-set:figure-counter-major 69;counter-reset:figure-counter-minor;}
  h1[data-number="70"]{counter-set:figure-counter-major 70;counter-reset:figure-counter-minor;}
  h1[data-number="71"]{counter-set:figure-counter-major 71;counter-reset:figure-counter-minor;}
  h1[data-number="72"]{counter-set:figure-counter-major 72;counter-reset:figure-counter-minor;}
  h1[data-number="73"]{counter-set:figure-counter-major 73;counter-reset:figure-counter-minor;}
  h1[data-number="74"]{counter-set:figure-counter-major 74;counter-reset:figure-counter-minor;}
  h1[data-number="75"]{counter-set:figure-counter-major 75;counter-reset:figure-counter-minor;}
  h1[data-number="76"]{counter-set:figure-counter-major 76;counter-reset:figure-counter-minor;}
  h1[data-number="77"]{counter-set:figure-counter-major 77;counter-reset:figure-counter-minor;}
  h1[data-number="78"]{counter-set:figure-counter-major 78;counter-reset:figure-counter-minor;}
  h1[data-number="79"]{counter-set:figure-counter-major 79;counter-reset:figure-counter-minor;}
  h1[data-number="80"]{counter-set:figure-counter-major 80;counter-reset:figure-counter-minor;}
  h1[data-number="81"]{counter-set:figure-counter-major 81;counter-reset:figure-counter-minor;}
  h1[data-number="82"]{counter-set:figure-counter-major 82;counter-reset:figure-counter-minor;}
  h1[data-number="83"]{counter-set:figure-counter-major 83;counter-reset:figure-counter-minor;}
  h1[data-number="84"]{counter-set:figure-counter-major 84;counter-reset:figure-counter-minor;}
  h1[data-number="85"]{counter-set:figure-counter-major 85;counter-reset:figure-counter-minor;}
  h1[data-number="86"]{counter-set:figure-counter-major 86;counter-reset:figure-counter-minor;}
  h1[data-number="87"]{counter-set:figure-counter-major 87;counter-reset:figure-counter-minor;}
  h1[data-number="88"]{counter-set:figure-counter-major 88;counter-reset:figure-counter-minor;}
  h1[data-number="89"]{counter-set:figure-counter-major 89;counter-reset:figure-counter-minor;}
  h1[data-number="90"]{counter-set:figure-counter-major 90;counter-reset:figure-counter-minor;}
  h1[data-number="91"]{counter-set:figure-counter-major 91;counter-reset:figure-counter-minor;}
  h1[data-number="92"]{counter-set:figure-counter-major 92;counter-reset:figure-counter-minor;}
  h1[data-number="93"]{counter-set:figure-counter-major 93;counter-reset:figure-counter-minor;}
  h1[data-number="94"]{counter-set:figure-counter-major 94;counter-reset:figure-counter-minor;}
  h1[data-number="95"]{counter-set:figure-counter-major 95;counter-reset:figure-counter-minor;}
  h1[data-number="96"]{counter-set:figure-counter-major 96;counter-reset:figure-counter-minor;}
  h1[data-number="97"]{counter-set:figure-counter-major 97;counter-reset:figure-counter-minor;}
  h1[data-number="98"]{counter-set:figure-counter-major 98;counter-reset:figure-counter-minor;}
  h1[data-number="99"]{counter-set:figure-counter-major 99;counter-reset:figure-counter-minor;}


  </style>
  <!-- BG custom styling for the wide body variant -->
  <!-- Gets appended after bg-css.html -->

  <style type="text/css">
  body {
      max-width: inherit;
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body>
<div style="text-align:center"><span><a href="typedef-making-new-types.html" rel="prev">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="manual-memory-allocation.html" rel="next">Next</a></span></div><hr>
<h1 data-number="11" id="pointers2"><span class="header-section-number">11</span> Pointers II: Arithmetic</h1>
<p></p>
<p>Time to get more into it with a number of new pointer topics! If you’re not up to speed with pointers, <a href="pointers.html#pointers">check out the first section in the guide on the matter</a>.</p>
<h2 data-number="11.1" id="pointer-arithmetic"><span class="header-section-number">11.1</span> Pointer Arithmetic</h2>
<p>Turns out you can do math on pointers, notably addition and subtraction.</p>
<p>But what does it mean when you do that?</p>
<p>In short, if you have a pointer to a type, adding one to the pointer moves to the next item of that type directly after it in memory.</p>
<p>It’s <strong>important</strong> to remember that as we move pointers around and look at different places in memory, we need to make sure that we’re always pointing to a valid place in memory before we dereference. If we’re off in the weeds and we try to see what’s there, the behavior is undefined and a crash is a common result.</p>
<p>This is a little chicken-and-eggy with <a href="pointers2.html#arraypointerequiv">Array/Pointer Equivalence, below</a>, but we’re going to give it a shot, anyway.</p>
<h3 data-number="11.1.1" id="adding-to-pointers"><span class="header-section-number">11.1.1</span> Adding to Pointers</h3>
<p>First, let’s take an array of numbers.</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb172-1"><a href="pointers2.html#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span></code></pre></div>
<p>Then let’s get a pointer to the first element in that array:</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb173-1"><a href="pointers2.html#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb173-2"><a href="pointers2.html#cb173-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-3"><a href="pointers2.html#cb173-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span>  <span class="co">// Or &quot;int *p = a;&quot; works just as well</span></span></code></pre></div>
<p>Then let’s print the value there by dereferencing the pointer:</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb174-1"><a href="pointers2.html#cb174-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>  <span class="co">// Prints 11</span></span></code></pre></div>
<p>Now let’s use pointer arithmetic to print the next element in the array, the one at index 1:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb175-1"><a href="pointers2.html#cb175-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*(</span>p <span class="op">+</span> <span class="dv">1</span><span class="op">));</span>  <span class="co">// Prints 22!!</span></span></code></pre></div>
<p>What happened there? C knows that <code>p</code> is a pointer to an <code>int</code>. So it knows the <code>sizeof</code> an <code>int</code><a href="function-specifiers-alignment-specifiersoperators.html#fn84" class="footnote-ref" id="fnref84" role="doc-noteref"><sup>84</sup></a> and it knows to skip that many bytes to get to the next <code>int</code> after the first one!</p>
<p>In fact, the prior example could be written these two equivalent ways:</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb176-1"><a href="pointers2.html#cb176-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>        <span class="co">// Prints 11</span></span>
<span id="cb176-2"><a href="pointers2.html#cb176-2" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*(</span>p <span class="op">+</span> <span class="dv">0</span><span class="op">));</span>  <span class="co">// Prints 11</span></span></code></pre></div>
<p>because adding <code>0</code> to a pointer results in the same pointer.</p>
<p>Let’s think of the upshot here. We can iterate over elements of an array this way instead of using an array:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb177-1"><a href="pointers2.html#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb177-2"><a href="pointers2.html#cb177-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-3"><a href="pointers2.html#cb177-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span>  <span class="co">// Or &quot;int *p = a;&quot; works just as well</span></span>
<span id="cb177-4"><a href="pointers2.html#cb177-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-5"><a href="pointers2.html#cb177-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb177-6"><a href="pointers2.html#cb177-6" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*(</span>p <span class="op">+</span> i<span class="op">));</span>  <span class="co">// Same as p[i]!</span></span>
<span id="cb177-7"><a href="pointers2.html#cb177-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And that works the same as if we used array notation! Oooo! Getting closer to that array/pointer equivalence thing! More on this later in this chapter.</p>
<p>But what’s actually happening, here? How does it work?</p>
<p>Remember from early on that memory is like a big array, where a byte is stored at each array index?</p>
<p>And the array index into memory has a few names:</p>
<ul>
<li>Index into memory</li>
<li>Location</li>
<li>Address</li>
<li><em>Pointer!</em></li>
</ul>
<p>So a pointer is an index into memory, somewhere.</p>
<p>For a random example, say that a number 3490 was stored at address (“index”) 23,237,489,202. If we have an <code>int</code> pointer to that 3490, that value of that pointer is 23,237,489,202… because the pointer is the memory address. Different words for the same thing.</p>
<p>And now let’s say we have another number, 4096, stored right after the 3490 at address 23,237,489,210 (8 higher than the 3490 because each <code>int</code> in this example is 8 bytes long).</p>
<p>If we add <code>1</code> to that pointer, it actually jumps ahead <code>sizeof(int)</code> bytes to the next <code>int</code>. It knows to jump that far ahead because it’s an <code>int</code> pointer. If it were a <code>float</code> pointer, it’d jump <code>sizeof(float)</code> bytes ahead to get to the next float!</p>
<p>So you can look at the next <code>int</code>, by adding <code>1</code> to the pointer, the one after that by adding <code>2</code> to the pointer, and so on.</p>
<h3 data-number="11.1.2" id="changing-pointers"><span class="header-section-number">11.1.2</span> Changing Pointers</h3>
<p>We saw how we could add an integer to a pointer in the previous section. This time, let’s <em>modify the pointer, itself</em>.</p>
<p>You can just add (or subtract) integer values directly to (or from) any pointer!</p>
<p>Let’s do that example again, except with a couple changes. First, I’m going to add a <code>999</code> to the end of our numbers to act as a sentinel value. This will let us know where the end of the data is.</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb178-1"><a href="pointers2.html#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">,</span> <span class="dv">999</span><span class="op">};</span>  <span class="co">// Add 999 here as a sentinel</span></span>
<span id="cb178-2"><a href="pointers2.html#cb178-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-3"><a href="pointers2.html#cb178-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">];</span>  <span class="co">// p points to the 11</span></span></code></pre></div>
<p>And we also have <code>p</code> pointing to the element at index <code>0</code> of <code>a</code>, namely <code>11</code>, just like before.</p>
<p>Now—let’s start <em>incrementing</em> <code>p</code> so that it points at subsequent elements of the array. We’ll do this until <code>p</code> points to the <code>999</code>; that is, we’ll do it until <code>*p == 999</code>:</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb179-1"><a href="pointers2.html#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(*</span>p <span class="op">!=</span> <span class="dv">999</span><span class="op">)</span> <span class="op">{</span>       <span class="co">// While the thing p points to isn&#39;t 999</span></span>
<span id="cb179-2"><a href="pointers2.html#cb179-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>   <span class="co">// Print it</span></span>
<span id="cb179-3"><a href="pointers2.html#cb179-3" aria-hidden="true" tabindex="-1"></a>    p<span class="op">++;</span>                  <span class="co">// Move p to point to the next int!</span></span>
<span id="cb179-4"><a href="pointers2.html#cb179-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Pretty crazy, right?</p>
<p>When we give it a run, first <code>p</code> points to <code>11</code>. Then we increment <code>p</code>, and it points to <code>22</code>, and then again, it points to <code>33</code>. And so on, until it points to <code>999</code> and we quit.</p>
<h3 data-number="11.1.3" id="subtracting-pointers"><span class="header-section-number">11.1.3</span> Subtracting Pointers</h3>
<p> You can subtract a value from a pointer to get to earlier address, as well, just like we were adding to them before.</p>
<p>But we can also subtract two pointers to find the difference between them, e.g. we can calculate how many <code>int</code>s there are between two <code>int*</code>s. The catch is that this only works within a single array<a href="function-specifiers-alignment-specifiersoperators.html#fn85" class="footnote-ref" id="fnref85" role="doc-noteref"><sup>85</sup></a>—if the pointers point to anything else, you get undefined behavior.</p>
<p>Remember how strings are <code>char*</code>s in C? Let’s see if we can use this to write another variant of <code>strlen()</code> to compute the length of a string that utilizes pointer subtraction.</p>
<p>The idea is that if we have a pointer to the beginning of the string, we can find a pointer to the end of the string by scanning ahead for the <code>NUL</code> character.</p>
<p>And if we have a pointer to the beginning of the string, and we computed the pointer to the end of the string, we can just subtract the two pointers to come up with the length!</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb180-1"><a href="pointers2.html#cb180-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb180-2"><a href="pointers2.html#cb180-2"></a></span>
<span id="cb180-3"><a href="pointers2.html#cb180-3"></a><span class="dt">int</span> my_strlen<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb180-4"><a href="pointers2.html#cb180-4"></a><span class="op">{</span></span>
<span id="cb180-5"><a href="pointers2.html#cb180-5"></a>    <span class="co">// Start scanning from the beginning of the string</span></span>
<span id="cb180-6"><a href="pointers2.html#cb180-6"></a>    <span class="dt">char</span> <span class="op">*</span>p <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb180-7"><a href="pointers2.html#cb180-7"></a></span>
<span id="cb180-8"><a href="pointers2.html#cb180-8"></a>    <span class="co">// Scan until we find the NUL character</span></span>
<span id="cb180-9"><a href="pointers2.html#cb180-9"></a>    <span class="cf">while</span> <span class="op">(*</span>p <span class="op">!=</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">)</span></span>
<span id="cb180-10"><a href="pointers2.html#cb180-10"></a>        p<span class="op">++;</span></span>
<span id="cb180-11"><a href="pointers2.html#cb180-11"></a></span>
<span id="cb180-12"><a href="pointers2.html#cb180-12"></a>    <span class="co">// Return the difference in pointers</span></span>
<span id="cb180-13"><a href="pointers2.html#cb180-13"></a>    <span class="cf">return</span> p <span class="op">-</span> s<span class="op">;</span></span>
<span id="cb180-14"><a href="pointers2.html#cb180-14"></a><span class="op">}</span></span>
<span id="cb180-15"><a href="pointers2.html#cb180-15"></a></span>
<span id="cb180-16"><a href="pointers2.html#cb180-16"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb180-17"><a href="pointers2.html#cb180-17"></a><span class="op">{</span></span>
<span id="cb180-18"><a href="pointers2.html#cb180-18"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> my_strlen<span class="op">(</span><span class="st">&quot;Hello, world!&quot;</span><span class="op">));</span>  <span class="co">// Prints &quot;13&quot;</span></span>
<span id="cb180-19"><a href="pointers2.html#cb180-19"></a><span class="op">}</span></span></code></pre></div>
<p>Remember that you can only use pointer subtraction between two pointers that point to the same array! </p>
<h2 data-number="11.2" id="arraypointerequiv"><span class="header-section-number">11.2</span> Array/Pointer Equivalence</h2>
<p> We’re finally ready to talk about this! We’ve seen plenty of examples of places where we’ve intermixed array notation, but let’s give out the <em>fundamental formula of array/pointer equivalence</em>:</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb181-1"><a href="pointers2.html#cb181-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">[</span>b<span class="op">]</span> <span class="op">==</span> <span class="op">*(</span>a <span class="op">+</span> b<span class="op">)</span></span></code></pre></div>
<p>Study that! Those are equivalent and can be used interchangeably!</p>
<p>I’ve oversimplified a bit, because in my above example <code>a</code> and <code>b</code> can both be expressions, and we might want a few more parentheses to force order of operations in case the expressions are complex.</p>
<p>The spec is specific, as always, declaring (in C11 §6.5.2.1¶2):</p>
<blockquote>
<p><code>E1[E2]</code> is identical to <code>(*((E1)+(E2)))</code></p>
</blockquote>
<p>but that’s a little harder to grok. Just make sure you include parentheses if the expressions are complicated so all your math happens in the right order.</p>
<p>This means we can <em>decide</em> if we’re going to use array or pointer notation for any array or pointer (assuming it points to an element of an array).</p>
<p>Let’s use an array and pointer with both array and pointer notation:</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb182-1"><a href="pointers2.html#cb182-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb182-2"><a href="pointers2.html#cb182-2"></a></span>
<span id="cb182-3"><a href="pointers2.html#cb182-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb182-4"><a href="pointers2.html#cb182-4"></a><span class="op">{</span></span>
<span id="cb182-5"><a href="pointers2.html#cb182-5"></a>    <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb182-6"><a href="pointers2.html#cb182-6"></a></span>
<span id="cb182-7"><a href="pointers2.html#cb182-7"></a>    <span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> a<span class="op">;</span>  <span class="co">// p points to the first element of a, 11</span></span>
<span id="cb182-8"><a href="pointers2.html#cb182-8"></a></span>
<span id="cb182-9"><a href="pointers2.html#cb182-9"></a>    <span class="co">// Print all elements of the array a variety of ways:</span></span>
<span id="cb182-10"><a href="pointers2.html#cb182-10"></a></span>
<span id="cb182-11"><a href="pointers2.html#cb182-11"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb182-12"><a href="pointers2.html#cb182-12"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">[</span>i<span class="op">]);</span>      <span class="co">// Array notation with a</span></span>
<span id="cb182-13"><a href="pointers2.html#cb182-13"></a></span>
<span id="cb182-14"><a href="pointers2.html#cb182-14"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb182-15"><a href="pointers2.html#cb182-15"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> p<span class="op">[</span>i<span class="op">]);</span>      <span class="co">// Array notation with p</span></span>
<span id="cb182-16"><a href="pointers2.html#cb182-16"></a></span>
<span id="cb182-17"><a href="pointers2.html#cb182-17"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb182-18"><a href="pointers2.html#cb182-18"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*(</span>a <span class="op">+</span> i<span class="op">));</span>  <span class="co">// Pointer notation with a</span></span>
<span id="cb182-19"><a href="pointers2.html#cb182-19"></a></span>
<span id="cb182-20"><a href="pointers2.html#cb182-20"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb182-21"><a href="pointers2.html#cb182-21"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*(</span>p <span class="op">+</span> i<span class="op">));</span>  <span class="co">// Pointer notation with p</span></span>
<span id="cb182-22"><a href="pointers2.html#cb182-22"></a></span>
<span id="cb182-23"><a href="pointers2.html#cb182-23"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb182-24"><a href="pointers2.html#cb182-24"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*(</span>p<span class="op">++));</span>    <span class="co">// Moving pointer p</span></span>
<span id="cb182-25"><a href="pointers2.html#cb182-25"></a>        <span class="co">//printf(&quot;%d\n&quot;, *(a++));    // Moving array variable a--ERROR!</span></span>
<span id="cb182-26"><a href="pointers2.html#cb182-26"></a><span class="op">}</span></span></code></pre></div>
<p>So you can see that in general, if you have an array variable, you can use pointer or array notion to access elements. Same with a pointer variable.</p>
<p>The one big difference is that you can <em>modify</em> a pointer to point to a different address, but you can’t do that with an array variable. <!--
6.3.2.1p2 --></p>
<h3 data-number="11.2.1" id="arraypointer-equivalence-in-function-calls"><span class="header-section-number">11.2.1</span> Array/Pointer Equivalence in Function Calls</h3>
<p>This is where you’ll encounter this concept the most, for sure.</p>
<p>If you have a function that takes a pointer argument, e.g.:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb183-1"><a href="pointers2.html#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> my_strlen<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>s<span class="op">)</span></span></code></pre></div>
<p>this means you can pass either an array or a pointer to this function and have it work!</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb184-1"><a href="pointers2.html#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> s<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Antelopes&quot;</span><span class="op">;</span></span>
<span id="cb184-2"><a href="pointers2.html#cb184-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>t <span class="op">=</span> <span class="st">&quot;Wombats&quot;</span><span class="op">;</span></span>
<span id="cb184-3"><a href="pointers2.html#cb184-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-4"><a href="pointers2.html#cb184-4" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> my_strlen<span class="op">(</span>s<span class="op">));</span>  <span class="co">// Works!</span></span>
<span id="cb184-5"><a href="pointers2.html#cb184-5" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> my_strlen<span class="op">(</span>t<span class="op">));</span>  <span class="co">// Works, too!</span></span></code></pre></div>
<p>And it’s also why these two function signatures are equivalent:</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb185-1"><a href="pointers2.html#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> my_strlen<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>s<span class="op">)</span>    <span class="co">// Works!</span></span>
<span id="cb185-2"><a href="pointers2.html#cb185-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> my_strlen<span class="op">(</span><span class="dt">char</span> s<span class="op">[])</span>   <span class="co">// Works, too!</span></span></code></pre></div>
<p></p>
<h2 data-number="11.3" id="void-pointers"><span class="header-section-number">11.3</span> <code>void</code> Pointers</h2>
<p></p>
<p>You’ve already seen the <code>void</code> keyword used with functions, but this is an entirely separate, unrelated animal.</p>
<p>Sometimes it’s useful to have a pointer to a thing <em>that you don’t know the type of</em>.</p>
<p>I know. Bear with me just a second.</p>
<p>There are basically two use cases for this.</p>
<p></p>
<ol type="1">
<li><p>A function is going to operate on something byte-by-byte. For example, <code>memcpy()</code> copies bytes of memory from one pointer to another, but those pointers can point to any type. <code>memcpy()</code> takes advantage of the fact that if you iterate through <code>char*</code>s, you’re iterating through the bytes of an object no matter what type the object is. More on this in the <a href="pointers-iii-pointers-to-pointers-and-more.html#multibyte-values">Multibyte Values</a> subsection.</p></li>
<li><p>Another function is calling a function you passed to it (a callback), and it’s passing you data. You know the type of the data, but the function calling you doesn’t. So it passes you <code>void*</code>s—’cause it doesn’t know the type—and you convert those to the type you need. The built-in <a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-qsort"><code>qsort()</code></a><a href="function-specifiers-alignment-specifiersoperators.html#fn86" class="footnote-ref" id="fnref86" role="doc-noteref"><sup>86</sup></a> and <a href="https://beej.us/guide/bgclr/html/split/stdlib.html#man-bsearch"><code>bsearch()</code></a><a href="function-specifiers-alignment-specifiersoperators.html#fn87" class="footnote-ref" id="fnref87" role="doc-noteref"><sup>87</sup></a> use this technique.</p></li>
</ol>
<p>Let’s look at an example, the built-in <code>memcpy()</code> function:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb186-1"><a href="pointers2.html#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>memcpy<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>s1<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>s2<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">);</span></span></code></pre></div>
<p>This function copies <code>n</code> bytes of memory starting from address <code>s2</code> into the memory starting at address <code>s1</code>.</p>
<p>But look! <code>s1</code> and <code>s2</code> are <code>void*</code>s! Why? What does it mean? Let’s run more examples to see.</p>
<p>For instance, we could copy a string with <code>memcpy()</code> (though <code>strcpy()</code> is more appropriate for strings):</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb187-1"><a href="pointers2.html#cb187-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb187-2"><a href="pointers2.html#cb187-2"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb187-3"><a href="pointers2.html#cb187-3"></a></span>
<span id="cb187-4"><a href="pointers2.html#cb187-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb187-5"><a href="pointers2.html#cb187-5"></a><span class="op">{</span></span>
<span id="cb187-6"><a href="pointers2.html#cb187-6"></a>    <span class="dt">char</span> s<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;Goats!&quot;</span><span class="op">;</span></span>
<span id="cb187-7"><a href="pointers2.html#cb187-7"></a>    <span class="dt">char</span> t<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb187-8"><a href="pointers2.html#cb187-8"></a></span>
<span id="cb187-9"><a href="pointers2.html#cb187-9"></a>    memcpy<span class="op">(</span>t<span class="op">,</span> s<span class="op">,</span> <span class="dv">7</span><span class="op">);</span>  <span class="co">// Copy 7 bytes--including the NUL terminator!</span></span>
<span id="cb187-10"><a href="pointers2.html#cb187-10"></a></span>
<span id="cb187-11"><a href="pointers2.html#cb187-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> t<span class="op">);</span>  <span class="co">// &quot;Goats!&quot;</span></span>
<span id="cb187-12"><a href="pointers2.html#cb187-12"></a><span class="op">}</span></span></code></pre></div>
<p>Or we can copy some <code>int</code>s:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb188-1"><a href="pointers2.html#cb188-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb188-2"><a href="pointers2.html#cb188-2"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb188-3"><a href="pointers2.html#cb188-3"></a></span>
<span id="cb188-4"><a href="pointers2.html#cb188-4"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb188-5"><a href="pointers2.html#cb188-5"></a><span class="op">{</span></span>
<span id="cb188-6"><a href="pointers2.html#cb188-6"></a>    <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">};</span></span>
<span id="cb188-7"><a href="pointers2.html#cb188-7"></a>    <span class="dt">int</span> b<span class="op">[</span><span class="dv">3</span><span class="op">];</span></span>
<span id="cb188-8"><a href="pointers2.html#cb188-8"></a></span>
<span id="cb188-9"><a href="pointers2.html#cb188-9"></a>    memcpy<span class="op">(</span>b<span class="op">,</span> a<span class="op">,</span> <span class="dv">3</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span>  <span class="co">// Copy 3 ints of data</span></span>
<span id="cb188-10"><a href="pointers2.html#cb188-10"></a></span>
<span id="cb188-11"><a href="pointers2.html#cb188-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> b<span class="op">[</span><span class="dv">1</span><span class="op">]);</span>  <span class="co">// 22</span></span>
<span id="cb188-12"><a href="pointers2.html#cb188-12"></a><span class="op">}</span></span></code></pre></div>
<p>That one’s a little wild—you see what we did there with <code>memcpy()</code>? We copied the data from <code>a</code> to <code>b</code>, but we had to specify how many <em>bytes</em> to copy, and an <code>int</code> is more than one byte.</p>
<p>OK, then—how many bytes does an <code>int</code> take? Answer: depends on the system. But we can tell how many bytes any type takes with the <code>sizeof</code> operator.</p>
<p>So there’s the answer: an <code>int</code> takes <code>sizeof(int)</code> bytes of memory to store.</p>
<p>And if we have 3 of them in our array, like we did in that example, the entire space used for the 3 <code>int</code>s must be <code>3 * sizeof(int)</code>.</p>
<p>(In the string example, earlier, it would have been more technically accurate to copy <code>7 * sizeof(char)</code> bytes. But <code>char</code>s are always one byte large, by definition, so that just devolves into <code>7 * 1</code>.)</p>
<p>We could even copy a <code>float</code> or a <code>struct</code> with <code>memcpy()</code>! (Though this is abusive—we should just use <code>=</code> for that):</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb189-1"><a href="pointers2.html#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> antelope my_antelope<span class="op">;</span></span>
<span id="cb189-2"><a href="pointers2.html#cb189-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> antelope my_clone_antelope<span class="op">;</span></span>
<span id="cb189-3"><a href="pointers2.html#cb189-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-4"><a href="pointers2.html#cb189-4" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb189-5"><a href="pointers2.html#cb189-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-6"><a href="pointers2.html#cb189-6" aria-hidden="true" tabindex="-1"></a>memcpy<span class="op">(&amp;</span>my_clone_antelope<span class="op">,</span> <span class="op">&amp;</span>my_antelope<span class="op">,</span> <span class="kw">sizeof</span> my_antelope<span class="op">);</span></span></code></pre></div>
<p>Look at how versatile <code>memcpy()</code> is! If you have a pointer to a source and a pointer to a destination, and you have the number of bytes you want to copy, you can copy <em>any type of data</em>.</p>
<p>Imagine if we didn’t have <code>void*</code>. We’d have to write specialized <code>memcpy()</code> functions for each type:</p>
<p></p>
<div class="sourceCode" id="cb190"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb190-1"><a href="pointers2.html#cb190-1" aria-hidden="true" tabindex="-1"></a>memcpy_int<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>b<span class="op">,</span> <span class="dt">int</span> count<span class="op">);</span></span>
<span id="cb190-2"><a href="pointers2.html#cb190-2" aria-hidden="true" tabindex="-1"></a>memcpy_float<span class="op">(</span><span class="dt">float</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">float</span> <span class="op">*</span>b<span class="op">,</span> <span class="dt">int</span> count<span class="op">);</span></span>
<span id="cb190-3"><a href="pointers2.html#cb190-3" aria-hidden="true" tabindex="-1"></a>memcpy_double<span class="op">(</span><span class="dt">double</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">double</span> <span class="op">*</span>b<span class="op">,</span> <span class="dt">int</span> count<span class="op">);</span></span>
<span id="cb190-4"><a href="pointers2.html#cb190-4" aria-hidden="true" tabindex="-1"></a>memcpy_char<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>b<span class="op">,</span> <span class="dt">int</span> count<span class="op">);</span></span>
<span id="cb190-5"><a href="pointers2.html#cb190-5" aria-hidden="true" tabindex="-1"></a>memcpy_unsigned_char<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>b<span class="op">,</span> <span class="dt">int</span> count<span class="op">);</span></span>
<span id="cb190-6"><a href="pointers2.html#cb190-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-7"><a href="pointers2.html#cb190-7" aria-hidden="true" tabindex="-1"></a><span class="co">// etc... blech!</span></span></code></pre></div>
<p>Much better to just use <code>void*</code> and have one function that can do it all.</p>
<p>That’s the power of <code>void*</code>. You can write functions that don’t care about the type and is still able to do things with it.</p>
<p>But with great power comes great responsibility. Maybe not <em>that</em> great in this case, but there are some limits.</p>
<p></p>
<ol type="1">
<li>You cannot do pointer arithmetic on a <code>void*</code>.</li>
<li>You cannot dereference a <code>void*</code>.</li>
<li>You cannot use the arrow operator on a <code>void*</code>, since it’s also a dereference.</li>
<li>You cannot use array notation on a <code>void*</code>, since it’s also a dereference, as well<a href="function-specifiers-alignment-specifiersoperators.html#fn88" class="footnote-ref" id="fnref88" role="doc-noteref"><sup>88</sup></a>.</li>
</ol>
<p>And if you think about it, these rules make sense. All those operations rely on knowing the <code>sizeof</code> the type of data pointed to, and with <code>void*</code>, we don’t know the size of the data being pointed to—it could be anything!</p>
<p></p>
<p>But wait—if you can’t dereference a <code>void*</code> what good can it ever do you?</p>
<p>Like with <code>memcpy()</code>, it helps you write generic functions that can handle multiple types of data. But the secret is that, deep down, <em>you convert the <code>void*</code> to another type before you use it</em>!</p>
<p>And conversion is easy: you can just assign into a variable of the desired type<a href="function-specifiers-alignment-specifiersoperators.html#fn89" class="footnote-ref" id="fnref89" role="doc-noteref"><sup>89</sup></a>.</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb191-1"><a href="pointers2.html#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> a <span class="op">=</span> <span class="ch">&#39;X&#39;</span><span class="op">;</span>  <span class="co">// A single char</span></span>
<span id="cb191-2"><a href="pointers2.html#cb191-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-3"><a href="pointers2.html#cb191-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">;</span>  <span class="co">// p points to the &#39;X&#39;</span></span>
<span id="cb191-4"><a href="pointers2.html#cb191-4" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>q <span class="op">=</span> p<span class="op">;</span>   <span class="co">// q also points to the &#39;X&#39;</span></span>
<span id="cb191-5"><a href="pointers2.html#cb191-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-6"><a href="pointers2.html#cb191-6" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p<span class="op">);</span>  <span class="co">// ERROR--cannot dereference void*!</span></span>
<span id="cb191-7"><a href="pointers2.html#cb191-7" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>q<span class="op">);</span>  <span class="co">// Prints &quot;X&quot;</span></span></code></pre></div>
<p> Let’s write our own <code>memcpy()</code> to try this out. We can copy bytes (<code>char</code>s), and we know the number of bytes because it’s passed in.</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb192-1"><a href="pointers2.html#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>my_memcpy<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>dest<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>src<span class="op">,</span> <span class="dt">int</span> byte_count<span class="op">)</span></span>
<span id="cb192-2"><a href="pointers2.html#cb192-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb192-3"><a href="pointers2.html#cb192-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Convert void*s to char*s</span></span>
<span id="cb192-4"><a href="pointers2.html#cb192-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> src<span class="op">,</span> <span class="op">*</span>d <span class="op">=</span> dest<span class="op">;</span></span>
<span id="cb192-5"><a href="pointers2.html#cb192-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-6"><a href="pointers2.html#cb192-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now that we have char*s, we can dereference and copy them</span></span>
<span id="cb192-7"><a href="pointers2.html#cb192-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>byte_count<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb192-8"><a href="pointers2.html#cb192-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>d<span class="op">++</span> <span class="op">=</span> <span class="op">*</span>s<span class="op">++;</span></span>
<span id="cb192-9"><a href="pointers2.html#cb192-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb192-10"><a href="pointers2.html#cb192-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-11"><a href="pointers2.html#cb192-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Most of these functions return the destination, just in case</span></span>
<span id="cb192-12"><a href="pointers2.html#cb192-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that&#39;s useful to the caller.</span></span>
<span id="cb192-13"><a href="pointers2.html#cb192-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dest<span class="op">;</span></span>
<span id="cb192-14"><a href="pointers2.html#cb192-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Right there at the beginning, we copy the <code>void*</code>s into <code>char*</code>s so that we can use them as <code>char*</code>s. It’s as easy as that.</p>
<p>Then some fun in a while loop, where we decrement <code>byte_count</code> until it becomes false (<code>0</code>). Remember that with post-decrement, the value of the expression is computed (for <code>while</code> to use) and <em>then</em> the variable is decremented.</p>
<p>And some fun in the copy, where we assign <code>*d = *s</code> to copy the byte, but we do it with post-increment so that both <code>d</code> and <code>s</code> move to the next byte after the assignment is made.</p>
<p>Lastly, most memory and string functions return a copy of a pointer to the destination string just in case the caller wants to use it.</p>
<p>Now that we’ve done that, I just want to quickly point out that we can use this technique to iterate over the bytes of <em>any</em> object in C, <code>float</code>s, <code>struct</code>s, or anything! </p>
<p> <span id="qsort-example">Let’s</span> run one more real-world example with the built-in <code>qsort()</code> routine that can sort <em>anything</em> thanks to the magic of <code>void*</code>s.</p>
<p>(In the following example, you can ignore the word <code>const</code>, which we haven’t covered yet.)</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb193-1"><a href="pointers2.html#cb193-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb193-2"><a href="pointers2.html#cb193-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb193-3"><a href="pointers2.html#cb193-3"></a></span>
<span id="cb193-4"><a href="pointers2.html#cb193-4"></a><span class="co">// The type of structure we&#39;re going to sort</span></span>
<span id="cb193-5"><a href="pointers2.html#cb193-5"></a><span class="kw">struct</span> animal <span class="op">{</span></span>
<span id="cb193-6"><a href="pointers2.html#cb193-6"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb193-7"><a href="pointers2.html#cb193-7"></a>    <span class="dt">int</span> leg_count<span class="op">;</span></span>
<span id="cb193-8"><a href="pointers2.html#cb193-8"></a><span class="op">};</span></span>
<span id="cb193-9"><a href="pointers2.html#cb193-9"></a></span>
<span id="cb193-10"><a href="pointers2.html#cb193-10"></a><span class="co">// This is a comparison function called by qsort() to help it determine</span></span>
<span id="cb193-11"><a href="pointers2.html#cb193-11"></a><span class="co">// what exactly to sort by. We&#39;ll use it to sort an array of struct</span></span>
<span id="cb193-12"><a href="pointers2.html#cb193-12"></a><span class="co">// animals by leg_count.</span></span>
<span id="cb193-13"><a href="pointers2.html#cb193-13"></a><span class="dt">int</span> compar<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>elem1<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>elem2<span class="op">)</span></span>
<span id="cb193-14"><a href="pointers2.html#cb193-14"></a><span class="op">{</span></span>
<span id="cb193-15"><a href="pointers2.html#cb193-15"></a>    <span class="co">// We know we&#39;re sorting struct animals, so let&#39;s make both</span></span>
<span id="cb193-16"><a href="pointers2.html#cb193-16"></a>    <span class="co">// arguments pointers to struct animals</span></span>
<span id="cb193-17"><a href="pointers2.html#cb193-17"></a>    <span class="dt">const</span> <span class="kw">struct</span> animal <span class="op">*</span>animal1 <span class="op">=</span> elem1<span class="op">;</span></span>
<span id="cb193-18"><a href="pointers2.html#cb193-18"></a>    <span class="dt">const</span> <span class="kw">struct</span> animal <span class="op">*</span>animal2 <span class="op">=</span> elem2<span class="op">;</span></span>
<span id="cb193-19"><a href="pointers2.html#cb193-19"></a></span>
<span id="cb193-20"><a href="pointers2.html#cb193-20"></a>    <span class="co">// Return &lt;0 =0 or &gt;0 depending on whatever we want to sort by.</span></span>
<span id="cb193-21"><a href="pointers2.html#cb193-21"></a></span>
<span id="cb193-22"><a href="pointers2.html#cb193-22"></a>    <span class="co">// Let&#39;s sort ascending by leg_count, so we&#39;ll return the difference</span></span>
<span id="cb193-23"><a href="pointers2.html#cb193-23"></a>    <span class="co">// in the leg_counts</span></span>
<span id="cb193-24"><a href="pointers2.html#cb193-24"></a>    <span class="cf">if</span> <span class="op">(</span>animal1<span class="op">-&gt;</span>leg_count <span class="op">&gt;</span> animal2<span class="op">-&gt;</span>leg_count<span class="op">)</span></span>
<span id="cb193-25"><a href="pointers2.html#cb193-25"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb193-26"><a href="pointers2.html#cb193-26"></a>    </span>
<span id="cb193-27"><a href="pointers2.html#cb193-27"></a>    <span class="cf">if</span> <span class="op">(</span>animal1<span class="op">-&gt;</span>leg_count <span class="op">&lt;</span> animal2<span class="op">-&gt;</span>leg_count<span class="op">)</span></span>
<span id="cb193-28"><a href="pointers2.html#cb193-28"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb193-29"><a href="pointers2.html#cb193-29"></a></span>
<span id="cb193-30"><a href="pointers2.html#cb193-30"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb193-31"><a href="pointers2.html#cb193-31"></a><span class="op">}</span></span>
<span id="cb193-32"><a href="pointers2.html#cb193-32"></a></span>
<span id="cb193-33"><a href="pointers2.html#cb193-33"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb193-34"><a href="pointers2.html#cb193-34"></a><span class="op">{</span></span>
<span id="cb193-35"><a href="pointers2.html#cb193-35"></a>    <span class="co">// Let&#39;s build an array of 4 struct animals with different</span></span>
<span id="cb193-36"><a href="pointers2.html#cb193-36"></a>    <span class="co">// characteristics. This array is out of order by leg_count, but</span></span>
<span id="cb193-37"><a href="pointers2.html#cb193-37"></a>    <span class="co">// we&#39;ll sort it in a second.</span></span>
<span id="cb193-38"><a href="pointers2.html#cb193-38"></a>    <span class="kw">struct</span> animal a<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb193-39"><a href="pointers2.html#cb193-39"></a>        <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;Dog&quot;</span><span class="op">,</span> <span class="op">.</span>leg_count<span class="op">=</span><span class="dv">4</span><span class="op">},</span></span>
<span id="cb193-40"><a href="pointers2.html#cb193-40"></a>        <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;Monkey&quot;</span><span class="op">,</span> <span class="op">.</span>leg_count<span class="op">=</span><span class="dv">2</span><span class="op">},</span></span>
<span id="cb193-41"><a href="pointers2.html#cb193-41"></a>        <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;Antelope&quot;</span><span class="op">,</span> <span class="op">.</span>leg_count<span class="op">=</span><span class="dv">4</span><span class="op">},</span></span>
<span id="cb193-42"><a href="pointers2.html#cb193-42"></a>        <span class="op">{.</span>name<span class="op">=</span><span class="st">&quot;Snake&quot;</span><span class="op">,</span> <span class="op">.</span>leg_count<span class="op">=</span><span class="dv">0</span><span class="op">}</span></span>
<span id="cb193-43"><a href="pointers2.html#cb193-43"></a>    <span class="op">};</span></span>
<span id="cb193-44"><a href="pointers2.html#cb193-44"></a></span>
<span id="cb193-45"><a href="pointers2.html#cb193-45"></a>    <span class="co">// Call qsort() to sort the array. qsort() needs to be told exactly</span></span>
<span id="cb193-46"><a href="pointers2.html#cb193-46"></a>    <span class="co">// what to sort this data by, and we&#39;ll do that inside the compar()</span></span>
<span id="cb193-47"><a href="pointers2.html#cb193-47"></a>    <span class="co">// function.</span></span>
<span id="cb193-48"><a href="pointers2.html#cb193-48"></a>    <span class="co">//</span></span>
<span id="cb193-49"><a href="pointers2.html#cb193-49"></a>    <span class="co">// This call is saying: qsort array a, which has 4 elements, and</span></span>
<span id="cb193-50"><a href="pointers2.html#cb193-50"></a>    <span class="co">// each element is sizeof(struct animal) bytes big, and this is the</span></span>
<span id="cb193-51"><a href="pointers2.html#cb193-51"></a>    <span class="co">// function that will compare any two elements.</span></span>
<span id="cb193-52"><a href="pointers2.html#cb193-52"></a>    qsort<span class="op">(</span>a<span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> animal<span class="op">),</span> compar<span class="op">);</span></span>
<span id="cb193-53"><a href="pointers2.html#cb193-53"></a></span>
<span id="cb193-54"><a href="pointers2.html#cb193-54"></a>    <span class="co">// Print them all out</span></span>
<span id="cb193-55"><a href="pointers2.html#cb193-55"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb193-56"><a href="pointers2.html#cb193-56"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">[</span>i<span class="op">].</span>leg_count<span class="op">,</span> a<span class="op">[</span>i<span class="op">].</span>name<span class="op">);</span></span>
<span id="cb193-57"><a href="pointers2.html#cb193-57"></a>    <span class="op">}</span></span>
<span id="cb193-58"><a href="pointers2.html#cb193-58"></a><span class="op">}</span></span></code></pre></div>
<p>As long as you give <code>qsort()</code> a function that can compare two items that you have in your array to be sorted, it can sort anything. And it does this without needing to have the types of the items hardcoded in there anywhere. <code>qsort()</code> just rearranges blocks of bytes based on the results of the <code>compar()</code> function you passed in. </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<hr><div style="text-align:center"><span><a href="typedef-making-new-types.html" rel="prev">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="manual-memory-allocation.html" rel="next">Next</a></span></div></body>
</html>
