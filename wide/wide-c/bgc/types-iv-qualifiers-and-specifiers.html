<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Beej's Guide to C Programming</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!-- BG custom styling -->
  <style type="text/css">
  /* Fix for line numbers not visible */
  pre.numberSource code > span {
      left: -1em;
  }
  pre.numberSource {
      margin-left: initial;
  }

  /* Put some space after the section numbers */
  span.toc-section-number::after {
      content: "\a0\a0\a0";  /* non-breaking whitespace */
  }

  /* Hide underlines on code number links */
  pre > code.sourceCode > span > a:first-child::before {
      text-decoration: none;
  }

  /* Color the source blocks */
  div.sourceCode {
      background-color: #f0f0f0;
  }

  /* Fix iOS big text rendering issue */
  pre > code.sourceCode > span {
      display: initial;
  }


  /* Color the inline code */
  code:not(.sourceCode) {
      background: #f0f0f0;
      padding-left: 0.2em;
      padding-right: 0.2em;
      border-radius: 0.2em;
  }

  pre.sourceCode {
      border: 1px solid #ccc;
      padding: 0.5em;
      border-radius: 0.2em;
  }

  /* Keep code tags from wrapping in tables */
  tbody code {
      white-space: nowrap;
  }

  /* Prevent hyphenation and hyphen breaks in code*/
  code {
      word-break: keep-all;
  }

  td {
      vertical-align: top;
  }

  body {
      font-size: 12pt;
      max-width: 43em;
      font-family: sans-serif;
  }

  html {
      background: #f9f9f9;
  }

  figure > embed {
      max-width: 100%;
  }

  figure {
      text-align: center;
      margin-top: 2em;
      margin-bottom: 2em;
  }

  figcaption {
      font-size: 0.9em;
      font-style: italic;
      margin-top: 0.6em;
  }

  body {
      counter-reset: figure-counter-major;
      counter-reset: figure-counter-minor;
  }

  figure {
      counter-increment: figure-counter-minor;
  }

  figcaption::before {
      content: "Figure " counter(figure-counter-major) "." counter(figure-counter-minor) ": ";
  }

  blockquote {
      border-left: 2px solid #bbb;
      color: #444;
  }

  /* Contents */

  nav[role="doc-toc"] > ul > li {
    font-weight: bold;
    margin-top: 1.2em;
  }

  nav[role="doc-toc"] > ul > li:first {
    font-weight: bold;
    margin-top: initial;
  }

  nav[role="doc-toc"] > ul > li > ul {
    font-weight: normal;
    margin-top: 0.3em;
  }

  /*
  In multipage, we need to reset the figure counter to the chapter
  number. Luckily, this is in the <h1 data-number> attribute. Unluckily,
  there is no way to get this in a general way.

  This doesn't work:

    h1[data-number] {
      counter-set: figure-counter-major attr(data-number);
    }

  Nor this:

    h1[data-number] {
      --figure-counter-major-value: attr(data-number);
      counter-set: figure-counter-major var(--figure-counter-major-value);
    }

  So, dumbly, we have a bunch of rules for all these sections, up to the
  maximum possible section.

  Here's a program to generate them:

    for (let i = 1; i < 100; i++)
        console.log(`h1[data-number="${i}"]{counter-set:figure-counter-major ${i};counter-reset:figure-counter-minor;}`);

  Note to self: never write a book with more than 99 frickin' chapters.
  */

  h1[data-number="1"]{counter-set:figure-counter-major 1;counter-reset:figure-counter-minor;}
  h1[data-number="2"]{counter-set:figure-counter-major 2;counter-reset:figure-counter-minor;}
  h1[data-number="3"]{counter-set:figure-counter-major 3;counter-reset:figure-counter-minor;}
  h1[data-number="4"]{counter-set:figure-counter-major 4;counter-reset:figure-counter-minor;}
  h1[data-number="5"]{counter-set:figure-counter-major 5;counter-reset:figure-counter-minor;}
  h1[data-number="6"]{counter-set:figure-counter-major 6;counter-reset:figure-counter-minor;}
  h1[data-number="7"]{counter-set:figure-counter-major 7;counter-reset:figure-counter-minor;}
  h1[data-number="8"]{counter-set:figure-counter-major 8;counter-reset:figure-counter-minor;}
  h1[data-number="9"]{counter-set:figure-counter-major 9;counter-reset:figure-counter-minor;}
  h1[data-number="10"]{counter-set:figure-counter-major 10;counter-reset:figure-counter-minor;}
  h1[data-number="11"]{counter-set:figure-counter-major 11;counter-reset:figure-counter-minor;}
  h1[data-number="12"]{counter-set:figure-counter-major 12;counter-reset:figure-counter-minor;}
  h1[data-number="13"]{counter-set:figure-counter-major 13;counter-reset:figure-counter-minor;}
  h1[data-number="14"]{counter-set:figure-counter-major 14;counter-reset:figure-counter-minor;}
  h1[data-number="15"]{counter-set:figure-counter-major 15;counter-reset:figure-counter-minor;}
  h1[data-number="16"]{counter-set:figure-counter-major 16;counter-reset:figure-counter-minor;}
  h1[data-number="17"]{counter-set:figure-counter-major 17;counter-reset:figure-counter-minor;}
  h1[data-number="18"]{counter-set:figure-counter-major 18;counter-reset:figure-counter-minor;}
  h1[data-number="19"]{counter-set:figure-counter-major 19;counter-reset:figure-counter-minor;}
  h1[data-number="20"]{counter-set:figure-counter-major 20;counter-reset:figure-counter-minor;}
  h1[data-number="21"]{counter-set:figure-counter-major 21;counter-reset:figure-counter-minor;}
  h1[data-number="22"]{counter-set:figure-counter-major 22;counter-reset:figure-counter-minor;}
  h1[data-number="23"]{counter-set:figure-counter-major 23;counter-reset:figure-counter-minor;}
  h1[data-number="24"]{counter-set:figure-counter-major 24;counter-reset:figure-counter-minor;}
  h1[data-number="25"]{counter-set:figure-counter-major 25;counter-reset:figure-counter-minor;}
  h1[data-number="26"]{counter-set:figure-counter-major 26;counter-reset:figure-counter-minor;}
  h1[data-number="27"]{counter-set:figure-counter-major 27;counter-reset:figure-counter-minor;}
  h1[data-number="28"]{counter-set:figure-counter-major 28;counter-reset:figure-counter-minor;}
  h1[data-number="29"]{counter-set:figure-counter-major 29;counter-reset:figure-counter-minor;}
  h1[data-number="30"]{counter-set:figure-counter-major 30;counter-reset:figure-counter-minor;}
  h1[data-number="31"]{counter-set:figure-counter-major 31;counter-reset:figure-counter-minor;}
  h1[data-number="32"]{counter-set:figure-counter-major 32;counter-reset:figure-counter-minor;}
  h1[data-number="33"]{counter-set:figure-counter-major 33;counter-reset:figure-counter-minor;}
  h1[data-number="34"]{counter-set:figure-counter-major 34;counter-reset:figure-counter-minor;}
  h1[data-number="35"]{counter-set:figure-counter-major 35;counter-reset:figure-counter-minor;}
  h1[data-number="36"]{counter-set:figure-counter-major 36;counter-reset:figure-counter-minor;}
  h1[data-number="37"]{counter-set:figure-counter-major 37;counter-reset:figure-counter-minor;}
  h1[data-number="38"]{counter-set:figure-counter-major 38;counter-reset:figure-counter-minor;}
  h1[data-number="39"]{counter-set:figure-counter-major 39;counter-reset:figure-counter-minor;}
  h1[data-number="40"]{counter-set:figure-counter-major 40;counter-reset:figure-counter-minor;}
  h1[data-number="41"]{counter-set:figure-counter-major 41;counter-reset:figure-counter-minor;}
  h1[data-number="42"]{counter-set:figure-counter-major 42;counter-reset:figure-counter-minor;}
  h1[data-number="43"]{counter-set:figure-counter-major 43;counter-reset:figure-counter-minor;}
  h1[data-number="44"]{counter-set:figure-counter-major 44;counter-reset:figure-counter-minor;}
  h1[data-number="45"]{counter-set:figure-counter-major 45;counter-reset:figure-counter-minor;}
  h1[data-number="46"]{counter-set:figure-counter-major 46;counter-reset:figure-counter-minor;}
  h1[data-number="47"]{counter-set:figure-counter-major 47;counter-reset:figure-counter-minor;}
  h1[data-number="48"]{counter-set:figure-counter-major 48;counter-reset:figure-counter-minor;}
  h1[data-number="49"]{counter-set:figure-counter-major 49;counter-reset:figure-counter-minor;}
  h1[data-number="50"]{counter-set:figure-counter-major 50;counter-reset:figure-counter-minor;}
  h1[data-number="51"]{counter-set:figure-counter-major 51;counter-reset:figure-counter-minor;}
  h1[data-number="52"]{counter-set:figure-counter-major 52;counter-reset:figure-counter-minor;}
  h1[data-number="53"]{counter-set:figure-counter-major 53;counter-reset:figure-counter-minor;}
  h1[data-number="54"]{counter-set:figure-counter-major 54;counter-reset:figure-counter-minor;}
  h1[data-number="55"]{counter-set:figure-counter-major 55;counter-reset:figure-counter-minor;}
  h1[data-number="56"]{counter-set:figure-counter-major 56;counter-reset:figure-counter-minor;}
  h1[data-number="57"]{counter-set:figure-counter-major 57;counter-reset:figure-counter-minor;}
  h1[data-number="58"]{counter-set:figure-counter-major 58;counter-reset:figure-counter-minor;}
  h1[data-number="59"]{counter-set:figure-counter-major 59;counter-reset:figure-counter-minor;}
  h1[data-number="60"]{counter-set:figure-counter-major 60;counter-reset:figure-counter-minor;}
  h1[data-number="61"]{counter-set:figure-counter-major 61;counter-reset:figure-counter-minor;}
  h1[data-number="62"]{counter-set:figure-counter-major 62;counter-reset:figure-counter-minor;}
  h1[data-number="63"]{counter-set:figure-counter-major 63;counter-reset:figure-counter-minor;}
  h1[data-number="64"]{counter-set:figure-counter-major 64;counter-reset:figure-counter-minor;}
  h1[data-number="65"]{counter-set:figure-counter-major 65;counter-reset:figure-counter-minor;}
  h1[data-number="66"]{counter-set:figure-counter-major 66;counter-reset:figure-counter-minor;}
  h1[data-number="67"]{counter-set:figure-counter-major 67;counter-reset:figure-counter-minor;}
  h1[data-number="68"]{counter-set:figure-counter-major 68;counter-reset:figure-counter-minor;}
  h1[data-number="69"]{counter-set:figure-counter-major 69;counter-reset:figure-counter-minor;}
  h1[data-number="70"]{counter-set:figure-counter-major 70;counter-reset:figure-counter-minor;}
  h1[data-number="71"]{counter-set:figure-counter-major 71;counter-reset:figure-counter-minor;}
  h1[data-number="72"]{counter-set:figure-counter-major 72;counter-reset:figure-counter-minor;}
  h1[data-number="73"]{counter-set:figure-counter-major 73;counter-reset:figure-counter-minor;}
  h1[data-number="74"]{counter-set:figure-counter-major 74;counter-reset:figure-counter-minor;}
  h1[data-number="75"]{counter-set:figure-counter-major 75;counter-reset:figure-counter-minor;}
  h1[data-number="76"]{counter-set:figure-counter-major 76;counter-reset:figure-counter-minor;}
  h1[data-number="77"]{counter-set:figure-counter-major 77;counter-reset:figure-counter-minor;}
  h1[data-number="78"]{counter-set:figure-counter-major 78;counter-reset:figure-counter-minor;}
  h1[data-number="79"]{counter-set:figure-counter-major 79;counter-reset:figure-counter-minor;}
  h1[data-number="80"]{counter-set:figure-counter-major 80;counter-reset:figure-counter-minor;}
  h1[data-number="81"]{counter-set:figure-counter-major 81;counter-reset:figure-counter-minor;}
  h1[data-number="82"]{counter-set:figure-counter-major 82;counter-reset:figure-counter-minor;}
  h1[data-number="83"]{counter-set:figure-counter-major 83;counter-reset:figure-counter-minor;}
  h1[data-number="84"]{counter-set:figure-counter-major 84;counter-reset:figure-counter-minor;}
  h1[data-number="85"]{counter-set:figure-counter-major 85;counter-reset:figure-counter-minor;}
  h1[data-number="86"]{counter-set:figure-counter-major 86;counter-reset:figure-counter-minor;}
  h1[data-number="87"]{counter-set:figure-counter-major 87;counter-reset:figure-counter-minor;}
  h1[data-number="88"]{counter-set:figure-counter-major 88;counter-reset:figure-counter-minor;}
  h1[data-number="89"]{counter-set:figure-counter-major 89;counter-reset:figure-counter-minor;}
  h1[data-number="90"]{counter-set:figure-counter-major 90;counter-reset:figure-counter-minor;}
  h1[data-number="91"]{counter-set:figure-counter-major 91;counter-reset:figure-counter-minor;}
  h1[data-number="92"]{counter-set:figure-counter-major 92;counter-reset:figure-counter-minor;}
  h1[data-number="93"]{counter-set:figure-counter-major 93;counter-reset:figure-counter-minor;}
  h1[data-number="94"]{counter-set:figure-counter-major 94;counter-reset:figure-counter-minor;}
  h1[data-number="95"]{counter-set:figure-counter-major 95;counter-reset:figure-counter-minor;}
  h1[data-number="96"]{counter-set:figure-counter-major 96;counter-reset:figure-counter-minor;}
  h1[data-number="97"]{counter-set:figure-counter-major 97;counter-reset:figure-counter-minor;}
  h1[data-number="98"]{counter-set:figure-counter-major 98;counter-reset:figure-counter-minor;}
  h1[data-number="99"]{counter-set:figure-counter-major 99;counter-reset:figure-counter-minor;}


  </style>
  <!-- BG custom styling for the wide body variant -->
  <!-- Gets appended after bg-css.html -->

  <style type="text/css">
  body {
      max-width: inherit;
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body>
<div style="text-align:center"><span><a href="types-iii-conversions.html" rel="prev">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="multifile-projects.html" rel="next">Next</a></span></div><hr>
<h1 data-number="16" id="types-iv-qualifiers-and-specifiers"><span class="header-section-number">16</span> Types IV: Qualifiers and Specifiers</h1>
<p>Now that we have some more types under our belts, turns out we can give these types some additional attributes that control their behavior. These are the <em>type qualifiers</em> and <em>storage-class specifiers</em>.</p>
<h2 data-number="16.1" id="type-qualifiers"><span class="header-section-number">16.1</span> Type Qualifiers</h2>
<p></p>
<p>These are going to allow you to declare constant values, and also to give the compiler optimization hints that it can use.</p>
<h3 data-number="16.1.1" id="const"><span class="header-section-number">16.1.1</span> <code>const</code></h3>
<p></p>
<p>This is the most common type qualifier you’ll see. It means the variable is constant, and any attempt to modify it will result in a very angry compiler.</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb263-1"><a href="types-iv-qualifiers-and-specifiers.html#cb263-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb263-2"><a href="types-iv-qualifiers-and-specifiers.html#cb263-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-3"><a href="types-iv-qualifiers-and-specifiers.html#cb263-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">4</span><span class="op">;</span>  <span class="co">// COMPILER PUKING SOUNDS, can&#39;t assign to a constant</span></span></code></pre></div>
<p>You can’t change a <code>const</code> value.</p>
<p>Often you see <code>const</code> in parameter lists for functions:</p>
<div class="sourceCode" id="cb264"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb264-1"><a href="types-iv-qualifiers-and-specifiers.html#cb264-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">const</span> <span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb264-2"><a href="types-iv-qualifiers-and-specifiers.html#cb264-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb264-3"><a href="types-iv-qualifiers-and-specifiers.html#cb264-3" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x <span class="op">+</span> <span class="dv">30</span><span class="op">);</span>  <span class="co">// OK, doesn&#39;t modify &quot;x&quot;</span></span>
<span id="cb264-4"><a href="types-iv-qualifiers-and-specifiers.html#cb264-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="16.1.1.1" id="const-and-pointers"><span class="header-section-number">16.1.1.1</span> <code>const</code> and Pointers</h4>
<p></p>
<p>This one gets a little funky, because there are two usages that have two meanings when it comes to pointers.</p>
<p>For one thing, we can make it so you can’t change the thing the pointer points to. You do this by putting the <code>const</code> up front with the type name (before the asterisk) in the type declaration.</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb265-1"><a href="types-iv-qualifiers-and-specifiers.html#cb265-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">};</span></span>
<span id="cb265-2"><a href="types-iv-qualifiers-and-specifiers.html#cb265-2" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> x<span class="op">;</span> </span>
<span id="cb265-3"><a href="types-iv-qualifiers-and-specifiers.html#cb265-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-4"><a href="types-iv-qualifiers-and-specifiers.html#cb265-4" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span>  <span class="co">// We can modify p, no problem</span></span>
<span id="cb265-5"><a href="types-iv-qualifiers-and-specifiers.html#cb265-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-6"><a href="types-iv-qualifiers-and-specifiers.html#cb265-6" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p <span class="op">=</span> <span class="dv">30</span><span class="op">;</span> <span class="co">// Compiler error! Can&#39;t change what it points to</span></span></code></pre></div>
<p>Somewhat confusingly, these two things are equivalent:</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb266-1"><a href="types-iv-qualifiers-and-specifiers.html#cb266-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span>  <span class="co">// Can&#39;t modify what p points to</span></span>
<span id="cb266-2"><a href="types-iv-qualifiers-and-specifiers.html#cb266-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="dt">const</span> <span class="op">*</span>p<span class="op">;</span>  <span class="co">// Can&#39;t modify what p points to, just like the previous line</span></span></code></pre></div>
<p>Great, so we can’t change the thing the pointer points to, but we can change the pointer itself. What if we want the other way around? We want to be able to change what the pointer points to, but <em>not</em> the pointer itself?</p>
<p>Just move the <code>const</code> after the asterisk in the declaration:</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb267-1"><a href="types-iv-qualifiers-and-specifiers.html#cb267-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> p<span class="op">;</span>   <span class="co">// We can&#39;t modify &quot;p&quot; with pointer arithmetic</span></span>
<span id="cb267-2"><a href="types-iv-qualifiers-and-specifiers.html#cb267-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-3"><a href="types-iv-qualifiers-and-specifiers.html#cb267-3" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span>  <span class="co">// Compiler error!</span></span></code></pre></div>
<p>But we can modify what they point to:</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb268-1"><a href="types-iv-qualifiers-and-specifiers.html#cb268-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb268-2"><a href="types-iv-qualifiers-and-specifiers.html#cb268-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb268-3"><a href="types-iv-qualifiers-and-specifiers.html#cb268-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb268-4"><a href="types-iv-qualifiers-and-specifiers.html#cb268-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p <span class="op">=</span> <span class="dv">20</span><span class="op">;</span>   <span class="co">// Set &quot;x&quot; to 20, no problem</span></span></code></pre></div>
<p>You can also do make both things <code>const</code>:</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb269-1"><a href="types-iv-qualifiers-and-specifiers.html#cb269-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> <span class="op">*</span><span class="dt">const</span> p<span class="op">;</span>  <span class="co">// Can&#39;t modify p or *p!</span></span></code></pre></div>
<p>Finally, if you have multiple levels of indirection, you should <code>const</code> the appropriate levels. Just because a pointer is <code>const</code>, doesn’t mean the pointer it points to must also be. You can explicitly set them like in the following examples:</p>
<div class="sourceCode" id="cb270"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb270-1"><a href="types-iv-qualifiers-and-specifiers.html#cb270-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">**</span>p<span class="op">;</span></span>
<span id="cb270-2"><a href="types-iv-qualifiers-and-specifiers.html#cb270-2" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span>     <span class="co">// OK!</span></span>
<span id="cb270-3"><a href="types-iv-qualifiers-and-specifiers.html#cb270-3" aria-hidden="true" tabindex="-1"></a><span class="op">(*</span>p<span class="op">)++;</span>  <span class="co">// OK!</span></span>
<span id="cb270-4"><a href="types-iv-qualifiers-and-specifiers.html#cb270-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-5"><a href="types-iv-qualifiers-and-specifiers.html#cb270-5" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">**</span><span class="dt">const</span> p<span class="op">;</span></span>
<span id="cb270-6"><a href="types-iv-qualifiers-and-specifiers.html#cb270-6" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span>     <span class="co">// Error!</span></span>
<span id="cb270-7"><a href="types-iv-qualifiers-and-specifiers.html#cb270-7" aria-hidden="true" tabindex="-1"></a><span class="op">(*</span>p<span class="op">)++;</span>  <span class="co">// OK!</span></span>
<span id="cb270-8"><a href="types-iv-qualifiers-and-specifiers.html#cb270-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-9"><a href="types-iv-qualifiers-and-specifiers.html#cb270-9" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span><span class="dt">const</span> <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb270-10"><a href="types-iv-qualifiers-and-specifiers.html#cb270-10" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span>     <span class="co">// OK!</span></span>
<span id="cb270-11"><a href="types-iv-qualifiers-and-specifiers.html#cb270-11" aria-hidden="true" tabindex="-1"></a><span class="op">(*</span>p<span class="op">)++;</span>  <span class="co">// Error!</span></span>
<span id="cb270-12"><a href="types-iv-qualifiers-and-specifiers.html#cb270-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-13"><a href="types-iv-qualifiers-and-specifiers.html#cb270-13" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span><span class="dt">const</span> <span class="op">*</span><span class="dt">const</span> p<span class="op">;</span></span>
<span id="cb270-14"><a href="types-iv-qualifiers-and-specifiers.html#cb270-14" aria-hidden="true" tabindex="-1"></a>p<span class="op">++;</span>     <span class="co">// Error!</span></span>
<span id="cb270-15"><a href="types-iv-qualifiers-and-specifiers.html#cb270-15" aria-hidden="true" tabindex="-1"></a><span class="op">(*</span>p<span class="op">)++;</span>  <span class="co">// Error!</span></span></code></pre></div>
<p></p>
<h4 data-number="16.1.1.2" id="const-correctness"><span class="header-section-number">16.1.1.2</span> <code>const</code> Correctness</h4>
<p></p>
<p>One more thing I have to mention is that the compiler will warn on something like this:</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb271-1"><a href="types-iv-qualifiers-and-specifiers.html#cb271-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb271-2"><a href="types-iv-qualifiers-and-specifiers.html#cb271-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span></code></pre></div>
<p>saying something to the effect of:</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb272-1"><a href="types-iv-qualifiers-and-specifiers.html#cb272-1" aria-hidden="true" tabindex="-1"></a>initialization discards &#39;const&#39; qualifier from pointer type target</span></code></pre></div>
<p>What’s happening there?</p>
<p>Well, we need to look at the types on either side of the assignment:</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb273-1"><a href="types-iv-qualifiers-and-specifiers.html#cb273-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb273-2"><a href="types-iv-qualifiers-and-specifiers.html#cb273-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb273-3"><a href="types-iv-qualifiers-and-specifiers.html#cb273-3" aria-hidden="true" tabindex="-1"></a><span class="co">//    ^       ^</span></span>
<span id="cb273-4"><a href="types-iv-qualifiers-and-specifiers.html#cb273-4" aria-hidden="true" tabindex="-1"></a><span class="co">//    |       |</span></span>
<span id="cb273-5"><a href="types-iv-qualifiers-and-specifiers.html#cb273-5" aria-hidden="true" tabindex="-1"></a><span class="co">//  int*    const int*</span></span></code></pre></div>
<p>The compiler is warning us that the value on the right side of the assignment is <code>const</code>, but the one of the left is not. And the compiler is letting us know that it is discarding the “const-ness” of the expression on the right.</p>
<p>That is, we <em>can</em> still try to do the following, but it’s just wrong. The compiler will warn, and it’s undefined behavior:</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb274-1"><a href="types-iv-qualifiers-and-specifiers.html#cb274-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb274-2"><a href="types-iv-qualifiers-and-specifiers.html#cb274-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb274-3"><a href="types-iv-qualifiers-and-specifiers.html#cb274-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-4"><a href="types-iv-qualifiers-and-specifiers.html#cb274-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p <span class="op">=</span> <span class="dv">40</span><span class="op">;</span>  <span class="co">// Undefined behavior--maybe it modifies &quot;x&quot;, maybe not!</span></span>
<span id="cb274-5"><a href="types-iv-qualifiers-and-specifiers.html#cb274-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-6"><a href="types-iv-qualifiers-and-specifiers.html#cb274-6" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span>  <span class="co">// 40, if you&#39;re lucky</span></span></code></pre></div>
<p> </p>
<h3 data-number="16.1.2" id="restrict"><span class="header-section-number">16.1.2</span> <code>restrict</code></h3>
<p></p>
<p>TLDR: you never have to use this and you can ignore it every time you see it. If you use it correctly, you will likely realize some performance gain. If you use it incorrectly, you will realize undefined behavior.</p>
<p><code>restrict</code> is a hint to the compiler that a particular piece of memory will only be accessed by one pointer and never another. (That is, there will be no aliasing of the particular object the <code>restrict</code> pointer points to.) If a developer declares a pointer to be <code>restrict</code> and then accesses the object it points to in another way (e.g. via another pointer), the behavior is undefined.</p>
<p>Basically you’re telling C, “Hey—I guarantee that this one single pointer is the only way I access this memory, and if I’m lying, you can pull undefined behavior on me.”</p>
<p>And C uses that information to perform certain optimizations. For instance, if you’re dereferencing the <code>restrict</code> pointer repeatedly in a loop, C might decide to cache the result in a register and only store the final result once the loop completes. If any other pointer referred to that same memory and accessed it in the loop, the results would not be accurate.</p>
<p>(Note that <code>restrict</code> has no effect if the object pointed to is never written to. It’s all about optimizations surrounding writes to memory.)</p>
<p>Let’s write a function to swap two variables, and we’ll use the <code>restrict</code> keyword to assure C that we’ll never pass in pointers to the same thing. And then let’s blow it and try passing in pointers to the same thing.</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb275-1"><a href="types-iv-qualifiers-and-specifiers.html#cb275-1"></a><span class="dt">void</span> swap<span class="op">(</span><span class="dt">int</span> <span class="op">*</span><span class="dt">restrict</span> a<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span><span class="dt">restrict</span> b<span class="op">)</span></span>
<span id="cb275-2"><a href="types-iv-qualifiers-and-specifiers.html#cb275-2"></a><span class="op">{</span></span>
<span id="cb275-3"><a href="types-iv-qualifiers-and-specifiers.html#cb275-3"></a>    <span class="dt">int</span> t<span class="op">;</span></span>
<span id="cb275-4"><a href="types-iv-qualifiers-and-specifiers.html#cb275-4"></a></span>
<span id="cb275-5"><a href="types-iv-qualifiers-and-specifiers.html#cb275-5"></a>    t <span class="op">=</span> <span class="op">*</span>a<span class="op">;</span></span>
<span id="cb275-6"><a href="types-iv-qualifiers-and-specifiers.html#cb275-6"></a>    <span class="op">*</span>a <span class="op">=</span> <span class="op">*</span>b<span class="op">;</span></span>
<span id="cb275-7"><a href="types-iv-qualifiers-and-specifiers.html#cb275-7"></a>    <span class="op">*</span>b <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb275-8"><a href="types-iv-qualifiers-and-specifiers.html#cb275-8"></a><span class="op">}</span></span>
<span id="cb275-9"><a href="types-iv-qualifiers-and-specifiers.html#cb275-9"></a></span>
<span id="cb275-10"><a href="types-iv-qualifiers-and-specifiers.html#cb275-10"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb275-11"><a href="types-iv-qualifiers-and-specifiers.html#cb275-11"></a><span class="op">{</span></span>
<span id="cb275-12"><a href="types-iv-qualifiers-and-specifiers.html#cb275-12"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> y <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb275-13"><a href="types-iv-qualifiers-and-specifiers.html#cb275-13"></a></span>
<span id="cb275-14"><a href="types-iv-qualifiers-and-specifiers.html#cb275-14"></a>    swap<span class="op">(&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span>  <span class="co">// OK! &quot;a&quot; and &quot;b&quot;, above, point to different things</span></span>
<span id="cb275-15"><a href="types-iv-qualifiers-and-specifiers.html#cb275-15"></a></span>
<span id="cb275-16"><a href="types-iv-qualifiers-and-specifiers.html#cb275-16"></a>    swap<span class="op">(&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">);</span>  <span class="co">// Undefined behavior! &quot;a&quot; and &quot;b&quot; point to the same thing</span></span>
<span id="cb275-17"><a href="types-iv-qualifiers-and-specifiers.html#cb275-17"></a><span class="op">}</span></span></code></pre></div>
<p>If we were to take out the <code>restrict</code> keywords, above, that would allow both calls to work safely. But then the compiler might not be able to optimize.</p>
<p><code>restrict</code> has block scope, that is, the restriction only lasts for the scope it’s used. If it’s in a parameter list for a function, it’s in the block scope of that function.</p>
<p>If the restricted pointer points to an array, it only applies to the individual objects in the array. Other pointers could read and write from the array as long as they didn’t read or write any of the same elements as the restricted one.</p>
<p>If it’s outside any function in file scope, the restriction covers the entire program.</p>
<p>You’re likely to see this in library functions like <code>printf()</code>:</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb276-1"><a href="types-iv-qualifiers-and-specifiers.html#cb276-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> printf<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span> <span class="dt">restrict</span> format<span class="op">,</span> <span class="op">...);</span></span></code></pre></div>
<p>Again, that’s just telling the compiler that inside the <code>printf()</code> function, there will be only one pointer that refers to any part of that <code>format</code> string.</p>
<p>One last note: if you’re using array notation in your function parameter for some reason instead of pointer notation, you can use <code>restrict</code> like so:</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb277-1"><a href="types-iv-qualifiers-and-specifiers.html#cb277-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span> p<span class="op">[</span><span class="dt">restrict</span><span class="op">])</span>     <span class="co">// With no size</span></span>
<span id="cb277-2"><a href="types-iv-qualifiers-and-specifiers.html#cb277-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-3"><a href="types-iv-qualifiers-and-specifiers.html#cb277-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span> p<span class="op">[</span><span class="dt">restrict</span> <span class="dv">10</span><span class="op">])</span>  <span class="co">// Or with a size</span></span></code></pre></div>
<p>But pointer notation would be more common.</p>
<p></p>
<h3 data-number="16.1.3" id="volatile"><span class="header-section-number">16.1.3</span> <code>volatile</code></h3>
<p></p>
<p>You’re unlikely to see or need this unless you’re dealing with hardware directly.</p>
<p><code>volatile</code> tells the compiler that a value might change behind its back and should be looked up every time.</p>
<p>An example might be where the compiler is looking in memory at an address that continuously updates behind the scenes, e.g. some kind of hardware timer.</p>
<p>If the compiler decides to optimize that and store the value in a register for a protracted time, the value in memory will update and won’t be reflected in the register.</p>
<p>By declaring something <code>volatile</code>, you’re telling the compiler, “Hey, the thing this points at might change at any time for reasons outside this program code.”</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb278-1"><a href="types-iv-qualifiers-and-specifiers.html#cb278-1" aria-hidden="true" tabindex="-1"></a><span class="dt">volatile</span> <span class="dt">int</span> <span class="op">*</span>p<span class="op">;</span></span></code></pre></div>
<h3 data-number="16.1.4" id="atomic"><span class="header-section-number">16.1.4</span> <code>_Atomic</code></h3>
<p>This is an optional C feature that we’ll talk about in <a href="chapter-atomics.html#chapter-atomics">the Atomics chapter</a>.</p>
<p> </p>
<h2 data-number="16.2" id="storage-class-specifiers"><span class="header-section-number">16.2</span> Storage-Class Specifiers</h2>
<p></p>
<p>Storage-class specifiers are similar to type quantifiers. They give the compiler more information about the type of a variable.</p>
<h3 data-number="16.2.1" id="auto"><span class="header-section-number">16.2.1</span> <code>auto</code></h3>
<p></p>
<p>You barely ever see this keyword, since <code>auto</code> is the default for block scope variables. It’s implied.</p>
<p>These are the same:</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb279-1"><a href="types-iv-qualifiers-and-specifiers.html#cb279-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb279-2"><a href="types-iv-qualifiers-and-specifiers.html#cb279-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">;</span>         <span class="co">// auto is the default...</span></span>
<span id="cb279-3"><a href="types-iv-qualifiers-and-specifiers.html#cb279-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="dt">int</span> a<span class="op">;</span>    <span class="co">// So this is redundant</span></span>
<span id="cb279-4"><a href="types-iv-qualifiers-and-specifiers.html#cb279-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>auto</code> keyword indicates that this object has <em>automatic storage duration</em>. That is, it exists in the scope in which it is defined, and is automatically deallocated when the scope is exited.</p>
<p>One gotcha about automatic variables is that their value is indeterminate until you explicitly initialize them. We say they’re full of “random” or “garbage” data, though neither of those really makes me happy. In any case, you won’t know what’s in it unless you initialize it.</p>
<p></p>
<p>Always initialize all automatic variables before use!</p>
<h3 data-number="16.2.2" id="static"><span class="header-section-number">16.2.2</span> <code>static</code></h3>
<p></p>
<p>This keyword has two meanings, depending on if the variable is file scope or block scope.</p>
<p>Let’s start with block scope.</p>
<h4 data-number="16.2.2.1" id="static-in-block-scope"><span class="header-section-number">16.2.2.1</span> <code>static</code> in Block Scope</h4>
<p></p>
<p>In this case, we’re basically saying, “I just want a single instance of this variable to exist, shared between calls.”</p>
<p>That is, its value will persist between calls.</p>
<p><code>static</code> in block scope with an initializer will only be initialized one time on program startup, not each time the function is called.</p>
<p>Let’s do an example:</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb280-1"><a href="types-iv-qualifiers-and-specifiers.html#cb280-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb280-2"><a href="types-iv-qualifiers-and-specifiers.html#cb280-2"></a></span>
<span id="cb280-3"><a href="types-iv-qualifiers-and-specifiers.html#cb280-3"></a><span class="dt">void</span> counter<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb280-4"><a href="types-iv-qualifiers-and-specifiers.html#cb280-4"></a><span class="op">{</span></span>
<span id="cb280-5"><a href="types-iv-qualifiers-and-specifiers.html#cb280-5"></a>    <span class="dt">static</span> <span class="dt">int</span> count <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// This is initialized one time</span></span>
<span id="cb280-6"><a href="types-iv-qualifiers-and-specifiers.html#cb280-6"></a></span>
<span id="cb280-7"><a href="types-iv-qualifiers-and-specifiers.html#cb280-7"></a>    printf<span class="op">(</span><span class="st">&quot;This has been called </span><span class="sc">%d</span><span class="st"> time(s)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> count<span class="op">);</span></span>
<span id="cb280-8"><a href="types-iv-qualifiers-and-specifiers.html#cb280-8"></a></span>
<span id="cb280-9"><a href="types-iv-qualifiers-and-specifiers.html#cb280-9"></a>    count<span class="op">++;</span></span>
<span id="cb280-10"><a href="types-iv-qualifiers-and-specifiers.html#cb280-10"></a><span class="op">}</span></span>
<span id="cb280-11"><a href="types-iv-qualifiers-and-specifiers.html#cb280-11"></a></span>
<span id="cb280-12"><a href="types-iv-qualifiers-and-specifiers.html#cb280-12"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb280-13"><a href="types-iv-qualifiers-and-specifiers.html#cb280-13"></a><span class="op">{</span></span>
<span id="cb280-14"><a href="types-iv-qualifiers-and-specifiers.html#cb280-14"></a>    counter<span class="op">();</span>  <span class="co">// &quot;This has been called 1 time(s)&quot;</span></span>
<span id="cb280-15"><a href="types-iv-qualifiers-and-specifiers.html#cb280-15"></a>    counter<span class="op">();</span>  <span class="co">// &quot;This has been called 2 time(s)&quot;</span></span>
<span id="cb280-16"><a href="types-iv-qualifiers-and-specifiers.html#cb280-16"></a>    counter<span class="op">();</span>  <span class="co">// &quot;This has been called 3 time(s)&quot;</span></span>
<span id="cb280-17"><a href="types-iv-qualifiers-and-specifiers.html#cb280-17"></a>    counter<span class="op">();</span>  <span class="co">// &quot;This has been called 4 time(s)&quot;</span></span>
<span id="cb280-18"><a href="types-iv-qualifiers-and-specifiers.html#cb280-18"></a><span class="op">}</span></span></code></pre></div>
<p>See how the value of <code>count</code> persists between calls?</p>
<p>One thing of note is that <code>static</code> block scope variables are initialized to <code>0</code> by default.</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb281-1"><a href="types-iv-qualifiers-and-specifiers.html#cb281-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">int</span> foo<span class="op">;</span>      <span class="co">// Default starting value is `0`...</span></span>
<span id="cb281-2"><a href="types-iv-qualifiers-and-specifiers.html#cb281-2" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">int</span> foo <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// So the `0` assignment is redundant</span></span></code></pre></div>
<p>Finally, be advised that if you’re writing multithreaded programs, you have to be sure you don’t let multiple threads trample the same variable.</p>
<p></p>
<h4 data-number="16.2.2.2" id="static-in-file-scope"><span class="header-section-number">16.2.2.2</span> <code>static</code> in File Scope</h4>
<p></p>
<p>When you get out to file scope, outside any blocks, the meaning rather changes.</p>
<p>Variables at file scope already persist between function calls, so that behavior is already there.</p>
<p>Instead what <code>static</code> means in this context is that this variable isn’t visible outside of this particular source file. Kinda like “global”, but only in this file.</p>
<p>More on that in the section about building with multiple source files.</p>
<p> </p>
<h3 data-number="16.2.3" id="extern"><span class="header-section-number">16.2.3</span> <code>extern</code></h3>
<p></p>
<p>The <code>extern</code> storage-class specifier gives us a way to refer to objects in other source files.</p>
<p>Let’s say, for example, the file <code>bar.c</code> had the following as its entirety:</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb282-1"><a href="types-iv-qualifiers-and-specifiers.html#cb282-1"></a><span class="co">// bar.c</span></span>
<span id="cb282-2"><a href="types-iv-qualifiers-and-specifiers.html#cb282-2"></a></span>
<span id="cb282-3"><a href="types-iv-qualifiers-and-specifiers.html#cb282-3"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">37</span><span class="op">;</span></span></code></pre></div>
<p>Just that. Declaring a new <code>int a</code> in file scope.</p>
<p>But what if we had another source file, <code>foo.c</code>, and we wanted to refer to the <code>a</code> that’s in <code>bar.c</code>?</p>
<p>It’s easy with the <code>extern</code> keyword:</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb283-1"><a href="types-iv-qualifiers-and-specifiers.html#cb283-1"></a><span class="co">// foo.c</span></span>
<span id="cb283-2"><a href="types-iv-qualifiers-and-specifiers.html#cb283-2"></a></span>
<span id="cb283-3"><a href="types-iv-qualifiers-and-specifiers.html#cb283-3"></a><span class="kw">extern</span> <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb283-4"><a href="types-iv-qualifiers-and-specifiers.html#cb283-4"></a></span>
<span id="cb283-5"><a href="types-iv-qualifiers-and-specifiers.html#cb283-5"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb283-6"><a href="types-iv-qualifiers-and-specifiers.html#cb283-6"></a><span class="op">{</span></span>
<span id="cb283-7"><a href="types-iv-qualifiers-and-specifiers.html#cb283-7"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// 37, from bar.c!</span></span>
<span id="cb283-8"><a href="types-iv-qualifiers-and-specifiers.html#cb283-8"></a></span>
<span id="cb283-9"><a href="types-iv-qualifiers-and-specifiers.html#cb283-9"></a>    a <span class="op">=</span> <span class="dv">99</span><span class="op">;</span></span>
<span id="cb283-10"><a href="types-iv-qualifiers-and-specifiers.html#cb283-10"></a></span>
<span id="cb283-11"><a href="types-iv-qualifiers-and-specifiers.html#cb283-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// Same &quot;a&quot; from bar.c, but it&#39;s now 99</span></span>
<span id="cb283-12"><a href="types-iv-qualifiers-and-specifiers.html#cb283-12"></a><span class="op">}</span></span></code></pre></div>
<p>We could have also made the <code>extern int a</code> in block scope, and it still would have referred to the <code>a</code> in <code>bar.c</code>:</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb284-1"><a href="types-iv-qualifiers-and-specifiers.html#cb284-1"></a><span class="co">// foo.c</span></span>
<span id="cb284-2"><a href="types-iv-qualifiers-and-specifiers.html#cb284-2"></a></span>
<span id="cb284-3"><a href="types-iv-qualifiers-and-specifiers.html#cb284-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb284-4"><a href="types-iv-qualifiers-and-specifiers.html#cb284-4"></a><span class="op">{</span></span>
<span id="cb284-5"><a href="types-iv-qualifiers-and-specifiers.html#cb284-5"></a>    <span class="kw">extern</span> <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb284-6"><a href="types-iv-qualifiers-and-specifiers.html#cb284-6"></a></span>
<span id="cb284-7"><a href="types-iv-qualifiers-and-specifiers.html#cb284-7"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// 37, from bar.c!</span></span>
<span id="cb284-8"><a href="types-iv-qualifiers-and-specifiers.html#cb284-8"></a></span>
<span id="cb284-9"><a href="types-iv-qualifiers-and-specifiers.html#cb284-9"></a>    a <span class="op">=</span> <span class="dv">99</span><span class="op">;</span></span>
<span id="cb284-10"><a href="types-iv-qualifiers-and-specifiers.html#cb284-10"></a></span>
<span id="cb284-11"><a href="types-iv-qualifiers-and-specifiers.html#cb284-11"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// Same &quot;a&quot; from bar.c, but it&#39;s now 99</span></span>
<span id="cb284-12"><a href="types-iv-qualifiers-and-specifiers.html#cb284-12"></a><span class="op">}</span></span></code></pre></div>
<p>Now, if <code>a</code> in <code>bar.c</code> had been marked <code>static</code>. this wouldn’t have worked. <code>static</code> variables at file scope are not visible outside that file.</p>
<p>A final note about <code>extern</code> on functions. For functions, <code>extern</code> is the default, so it’s redundant. You can declare a function <code>static</code> if you only want it visible in a single source file.</p>
<p></p>
<h3 data-number="16.2.4" id="register"><span class="header-section-number">16.2.4</span> <code>register</code></h3>
<p></p>
<p>This is a keyword to hint to the compiler that this variable is frequently-used, and should be made as fast as possible to access. The compiler is under no obligation to agree to it.</p>
<p>Now, modern C compiler optimizers are pretty effective at figuring this out themselves, so it’s rare to see these days.</p>
<p>But if you must:</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb285-1"><a href="types-iv-qualifiers-and-specifiers.html#cb285-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb285-2"><a href="types-iv-qualifiers-and-specifiers.html#cb285-2"></a></span>
<span id="cb285-3"><a href="types-iv-qualifiers-and-specifiers.html#cb285-3"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb285-4"><a href="types-iv-qualifiers-and-specifiers.html#cb285-4"></a><span class="op">{</span></span>
<span id="cb285-5"><a href="types-iv-qualifiers-and-specifiers.html#cb285-5"></a>    <span class="dt">register</span> <span class="dt">int</span> a<span class="op">;</span>   <span class="co">// Make &quot;a&quot; as fast to use as possible.</span></span>
<span id="cb285-6"><a href="types-iv-qualifiers-and-specifiers.html#cb285-6"></a></span>
<span id="cb285-7"><a href="types-iv-qualifiers-and-specifiers.html#cb285-7"></a>    <span class="cf">for</span> <span class="op">(</span>a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> a <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> a<span class="op">++)</span></span>
<span id="cb285-8"><a href="types-iv-qualifiers-and-specifiers.html#cb285-8"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">);</span></span>
<span id="cb285-9"><a href="types-iv-qualifiers-and-specifiers.html#cb285-9"></a><span class="op">}</span></span></code></pre></div>
<p>It does come at a price, however. You can’t take the address of a register:</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb286-1"><a href="types-iv-qualifiers-and-specifiers.html#cb286-1" aria-hidden="true" tabindex="-1"></a><span class="dt">register</span> <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb286-2"><a href="types-iv-qualifiers-and-specifiers.html#cb286-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">;</span>    <span class="co">// COMPILER ERROR! Can&#39;t take address of a register</span></span></code></pre></div>
<p>The same applies to any part of an array:</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb287-1"><a href="types-iv-qualifiers-and-specifiers.html#cb287-1" aria-hidden="true" tabindex="-1"></a><span class="dt">register</span> <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb287-2"><a href="types-iv-qualifiers-and-specifiers.html#cb287-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> a<span class="op">;</span>  <span class="co">// COMPILER ERROR! Can&#39;t take address of a[0]</span></span></code></pre></div>
<p>Or dereferencing part of an array:</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb288-1"><a href="types-iv-qualifiers-and-specifiers.html#cb288-1" aria-hidden="true" tabindex="-1"></a><span class="dt">register</span> <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb288-2"><a href="types-iv-qualifiers-and-specifiers.html#cb288-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-3"><a href="types-iv-qualifiers-and-specifiers.html#cb288-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="op">*(</span>a <span class="op">+</span> <span class="dv">2</span><span class="op">);</span>  <span class="co">// COMPILER ERROR! Address of a[0] taken</span></span></code></pre></div>
<p>Interestingly, for the equivalent with array notation, gcc only warns:</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb289-1"><a href="types-iv-qualifiers-and-specifiers.html#cb289-1" aria-hidden="true" tabindex="-1"></a><span class="dt">register</span> <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">11</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">33</span><span class="op">,</span> <span class="dv">44</span><span class="op">,</span> <span class="dv">55</span><span class="op">};</span></span>
<span id="cb289-2"><a href="types-iv-qualifiers-and-specifiers.html#cb289-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-3"><a href="types-iv-qualifiers-and-specifiers.html#cb289-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> a<span class="op">[</span><span class="dv">2</span><span class="op">];</span>  <span class="co">// COMPILER </span><span class="al">WARNING</span><span class="co">!</span></span></code></pre></div>
<p>with:</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb290-1"><a href="types-iv-qualifiers-and-specifiers.html#cb290-1" aria-hidden="true" tabindex="-1"></a>warning: ISO C forbids subscripting ‘register’ array</span></code></pre></div>
<p>The fact that you can’t take the address of a register variable frees the compiler up to make optimizations around that assumption if it hasn’t figured them out already. Also adding <code>register</code> to a <code>const</code> variable prevents one from accidentally passing its pointer to another function that willfully ignore its constness<a href="function-specifiers-alignment-specifiersoperators.html#fn117" class="footnote-ref" id="fnref117" role="doc-noteref"><sup>117</sup></a>.</p>
<p>A bit of historic backstory, here: deep inside the CPU are little dedicated “variables” called <a href="https://en.wikipedia.org/wiki/Processor_register"><em>registers</em></a><a href="function-specifiers-alignment-specifiersoperators.html#fn118" class="footnote-ref" id="fnref118" role="doc-noteref"><sup>118</sup></a>. They are super fast to access compared to RAM, so using them gets you a speed boost. But they’re not in RAM, so they don’t have an associated memory address (which is why you can’t take the address-of or get a pointer to them).</p>
<p>But, like I said, modern compilers are really good at producing optimal code, using registers whenever possible regardless of whether or not you specified the <code>register</code> keyword. Not only that, but the spec allows them to just treat it as if you’d typed <code>auto</code>, if they want. So no guarantees.</p>
<p></p>
<h3 data-number="16.2.5" id="thread_local"><span class="header-section-number">16.2.5</span> <code>_Thread_local</code></h3>
<p></p>
<p>When you’re using multiple threads and you have some variables in either global or <code>static</code> block scope, this is a way to make sure that each thread gets its own copy of the variable. This’ll help you avoid race conditions and threads stepping on each other’s toes.</p>
<p>If you’re in block scope, you have to use this along with either <code>extern</code> or <code>static</code>.</p>
<p>Also, if you include <code>&lt;threads.h&gt;</code>, you can use the rather more palatable <code>thread_local</code> as an alias for the uglier <code>_Thread_local</code>.</p>
<p>More information can be found in the <a href="multithreading.html#thread-local">Threads section</a>.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<hr><div style="text-align:center"><span><a href="types-iii-conversions.html" rel="prev">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="multifile-projects.html" rel="next">Next</a></span></div></body>
</html>
