<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Beej's Guide to C Programming</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!-- BG custom styling -->
  <style type="text/css">
  /* Fix for line numbers not visible */
  pre.numberSource code > span {
      left: -1em;
  }
  pre.numberSource {
      margin-left: initial;
  }

  /* Put some space after the section numbers */
  span.toc-section-number::after {
      content: "\a0\a0\a0";  /* non-breaking whitespace */
  }

  /* Hide underlines on code number links */
  pre > code.sourceCode > span > a:first-child::before {
      text-decoration: none;
  }

  /* Color the source blocks */
  div.sourceCode {
      background-color: #f0f0f0;
  }

  /* Fix iOS big text rendering issue */
  pre > code.sourceCode > span {
      display: initial;
  }


  /* Color the inline code */
  code:not(.sourceCode) {
      background: #f0f0f0;
      padding-left: 0.2em;
      padding-right: 0.2em;
      border-radius: 0.2em;
  }

  pre.sourceCode {
      border: 1px solid #ccc;
      padding: 0.5em;
      border-radius: 0.2em;
  }

  /* Keep code tags from wrapping in tables */
  tbody code {
      white-space: nowrap;
  }

  /* Prevent hyphenation and hyphen breaks in code*/
  code {
      word-break: keep-all;
  }

  td {
      vertical-align: top;
  }

  body {
      font-size: 12pt;
      max-width: 43em;
      font-family: sans-serif;
  }

  html {
      background: #f9f9f9;
  }

  figure > embed {
      max-width: 100%;
  }

  figure {
      text-align: center;
      margin-top: 2em;
      margin-bottom: 2em;
  }

  figcaption {
      font-size: 0.9em;
      font-style: italic;
      margin-top: 0.6em;
  }

  body {
      counter-reset: figure-counter-major;
      counter-reset: figure-counter-minor;
  }

  figure {
      counter-increment: figure-counter-minor;
  }

  figcaption::before {
      content: "Figure " counter(figure-counter-major) "." counter(figure-counter-minor) ": ";
  }

  blockquote {
      border-left: 2px solid #bbb;
      color: #444;
  }

  /* Contents */

  nav[role="doc-toc"] > ul > li {
    font-weight: bold;
    margin-top: 1.2em;
  }

  nav[role="doc-toc"] > ul > li:first {
    font-weight: bold;
    margin-top: initial;
  }

  nav[role="doc-toc"] > ul > li > ul {
    font-weight: normal;
    margin-top: 0.3em;
  }

  /*
  In multipage, we need to reset the figure counter to the chapter
  number. Luckily, this is in the <h1 data-number> attribute. Unluckily,
  there is no way to get this in a general way.

  This doesn't work:

    h1[data-number] {
      counter-set: figure-counter-major attr(data-number);
    }

  Nor this:

    h1[data-number] {
      --figure-counter-major-value: attr(data-number);
      counter-set: figure-counter-major var(--figure-counter-major-value);
    }

  So, dumbly, we have a bunch of rules for all these sections, up to the
  maximum possible section.

  Here's a program to generate them:

    for (let i = 1; i < 100; i++)
        console.log(`h1[data-number="${i}"]{counter-set:figure-counter-major ${i};counter-reset:figure-counter-minor;}`);

  Note to self: never write a book with more than 99 frickin' chapters.
  */

  h1[data-number="1"]{counter-set:figure-counter-major 1;counter-reset:figure-counter-minor;}
  h1[data-number="2"]{counter-set:figure-counter-major 2;counter-reset:figure-counter-minor;}
  h1[data-number="3"]{counter-set:figure-counter-major 3;counter-reset:figure-counter-minor;}
  h1[data-number="4"]{counter-set:figure-counter-major 4;counter-reset:figure-counter-minor;}
  h1[data-number="5"]{counter-set:figure-counter-major 5;counter-reset:figure-counter-minor;}
  h1[data-number="6"]{counter-set:figure-counter-major 6;counter-reset:figure-counter-minor;}
  h1[data-number="7"]{counter-set:figure-counter-major 7;counter-reset:figure-counter-minor;}
  h1[data-number="8"]{counter-set:figure-counter-major 8;counter-reset:figure-counter-minor;}
  h1[data-number="9"]{counter-set:figure-counter-major 9;counter-reset:figure-counter-minor;}
  h1[data-number="10"]{counter-set:figure-counter-major 10;counter-reset:figure-counter-minor;}
  h1[data-number="11"]{counter-set:figure-counter-major 11;counter-reset:figure-counter-minor;}
  h1[data-number="12"]{counter-set:figure-counter-major 12;counter-reset:figure-counter-minor;}
  h1[data-number="13"]{counter-set:figure-counter-major 13;counter-reset:figure-counter-minor;}
  h1[data-number="14"]{counter-set:figure-counter-major 14;counter-reset:figure-counter-minor;}
  h1[data-number="15"]{counter-set:figure-counter-major 15;counter-reset:figure-counter-minor;}
  h1[data-number="16"]{counter-set:figure-counter-major 16;counter-reset:figure-counter-minor;}
  h1[data-number="17"]{counter-set:figure-counter-major 17;counter-reset:figure-counter-minor;}
  h1[data-number="18"]{counter-set:figure-counter-major 18;counter-reset:figure-counter-minor;}
  h1[data-number="19"]{counter-set:figure-counter-major 19;counter-reset:figure-counter-minor;}
  h1[data-number="20"]{counter-set:figure-counter-major 20;counter-reset:figure-counter-minor;}
  h1[data-number="21"]{counter-set:figure-counter-major 21;counter-reset:figure-counter-minor;}
  h1[data-number="22"]{counter-set:figure-counter-major 22;counter-reset:figure-counter-minor;}
  h1[data-number="23"]{counter-set:figure-counter-major 23;counter-reset:figure-counter-minor;}
  h1[data-number="24"]{counter-set:figure-counter-major 24;counter-reset:figure-counter-minor;}
  h1[data-number="25"]{counter-set:figure-counter-major 25;counter-reset:figure-counter-minor;}
  h1[data-number="26"]{counter-set:figure-counter-major 26;counter-reset:figure-counter-minor;}
  h1[data-number="27"]{counter-set:figure-counter-major 27;counter-reset:figure-counter-minor;}
  h1[data-number="28"]{counter-set:figure-counter-major 28;counter-reset:figure-counter-minor;}
  h1[data-number="29"]{counter-set:figure-counter-major 29;counter-reset:figure-counter-minor;}
  h1[data-number="30"]{counter-set:figure-counter-major 30;counter-reset:figure-counter-minor;}
  h1[data-number="31"]{counter-set:figure-counter-major 31;counter-reset:figure-counter-minor;}
  h1[data-number="32"]{counter-set:figure-counter-major 32;counter-reset:figure-counter-minor;}
  h1[data-number="33"]{counter-set:figure-counter-major 33;counter-reset:figure-counter-minor;}
  h1[data-number="34"]{counter-set:figure-counter-major 34;counter-reset:figure-counter-minor;}
  h1[data-number="35"]{counter-set:figure-counter-major 35;counter-reset:figure-counter-minor;}
  h1[data-number="36"]{counter-set:figure-counter-major 36;counter-reset:figure-counter-minor;}
  h1[data-number="37"]{counter-set:figure-counter-major 37;counter-reset:figure-counter-minor;}
  h1[data-number="38"]{counter-set:figure-counter-major 38;counter-reset:figure-counter-minor;}
  h1[data-number="39"]{counter-set:figure-counter-major 39;counter-reset:figure-counter-minor;}
  h1[data-number="40"]{counter-set:figure-counter-major 40;counter-reset:figure-counter-minor;}
  h1[data-number="41"]{counter-set:figure-counter-major 41;counter-reset:figure-counter-minor;}
  h1[data-number="42"]{counter-set:figure-counter-major 42;counter-reset:figure-counter-minor;}
  h1[data-number="43"]{counter-set:figure-counter-major 43;counter-reset:figure-counter-minor;}
  h1[data-number="44"]{counter-set:figure-counter-major 44;counter-reset:figure-counter-minor;}
  h1[data-number="45"]{counter-set:figure-counter-major 45;counter-reset:figure-counter-minor;}
  h1[data-number="46"]{counter-set:figure-counter-major 46;counter-reset:figure-counter-minor;}
  h1[data-number="47"]{counter-set:figure-counter-major 47;counter-reset:figure-counter-minor;}
  h1[data-number="48"]{counter-set:figure-counter-major 48;counter-reset:figure-counter-minor;}
  h1[data-number="49"]{counter-set:figure-counter-major 49;counter-reset:figure-counter-minor;}
  h1[data-number="50"]{counter-set:figure-counter-major 50;counter-reset:figure-counter-minor;}
  h1[data-number="51"]{counter-set:figure-counter-major 51;counter-reset:figure-counter-minor;}
  h1[data-number="52"]{counter-set:figure-counter-major 52;counter-reset:figure-counter-minor;}
  h1[data-number="53"]{counter-set:figure-counter-major 53;counter-reset:figure-counter-minor;}
  h1[data-number="54"]{counter-set:figure-counter-major 54;counter-reset:figure-counter-minor;}
  h1[data-number="55"]{counter-set:figure-counter-major 55;counter-reset:figure-counter-minor;}
  h1[data-number="56"]{counter-set:figure-counter-major 56;counter-reset:figure-counter-minor;}
  h1[data-number="57"]{counter-set:figure-counter-major 57;counter-reset:figure-counter-minor;}
  h1[data-number="58"]{counter-set:figure-counter-major 58;counter-reset:figure-counter-minor;}
  h1[data-number="59"]{counter-set:figure-counter-major 59;counter-reset:figure-counter-minor;}
  h1[data-number="60"]{counter-set:figure-counter-major 60;counter-reset:figure-counter-minor;}
  h1[data-number="61"]{counter-set:figure-counter-major 61;counter-reset:figure-counter-minor;}
  h1[data-number="62"]{counter-set:figure-counter-major 62;counter-reset:figure-counter-minor;}
  h1[data-number="63"]{counter-set:figure-counter-major 63;counter-reset:figure-counter-minor;}
  h1[data-number="64"]{counter-set:figure-counter-major 64;counter-reset:figure-counter-minor;}
  h1[data-number="65"]{counter-set:figure-counter-major 65;counter-reset:figure-counter-minor;}
  h1[data-number="66"]{counter-set:figure-counter-major 66;counter-reset:figure-counter-minor;}
  h1[data-number="67"]{counter-set:figure-counter-major 67;counter-reset:figure-counter-minor;}
  h1[data-number="68"]{counter-set:figure-counter-major 68;counter-reset:figure-counter-minor;}
  h1[data-number="69"]{counter-set:figure-counter-major 69;counter-reset:figure-counter-minor;}
  h1[data-number="70"]{counter-set:figure-counter-major 70;counter-reset:figure-counter-minor;}
  h1[data-number="71"]{counter-set:figure-counter-major 71;counter-reset:figure-counter-minor;}
  h1[data-number="72"]{counter-set:figure-counter-major 72;counter-reset:figure-counter-minor;}
  h1[data-number="73"]{counter-set:figure-counter-major 73;counter-reset:figure-counter-minor;}
  h1[data-number="74"]{counter-set:figure-counter-major 74;counter-reset:figure-counter-minor;}
  h1[data-number="75"]{counter-set:figure-counter-major 75;counter-reset:figure-counter-minor;}
  h1[data-number="76"]{counter-set:figure-counter-major 76;counter-reset:figure-counter-minor;}
  h1[data-number="77"]{counter-set:figure-counter-major 77;counter-reset:figure-counter-minor;}
  h1[data-number="78"]{counter-set:figure-counter-major 78;counter-reset:figure-counter-minor;}
  h1[data-number="79"]{counter-set:figure-counter-major 79;counter-reset:figure-counter-minor;}
  h1[data-number="80"]{counter-set:figure-counter-major 80;counter-reset:figure-counter-minor;}
  h1[data-number="81"]{counter-set:figure-counter-major 81;counter-reset:figure-counter-minor;}
  h1[data-number="82"]{counter-set:figure-counter-major 82;counter-reset:figure-counter-minor;}
  h1[data-number="83"]{counter-set:figure-counter-major 83;counter-reset:figure-counter-minor;}
  h1[data-number="84"]{counter-set:figure-counter-major 84;counter-reset:figure-counter-minor;}
  h1[data-number="85"]{counter-set:figure-counter-major 85;counter-reset:figure-counter-minor;}
  h1[data-number="86"]{counter-set:figure-counter-major 86;counter-reset:figure-counter-minor;}
  h1[data-number="87"]{counter-set:figure-counter-major 87;counter-reset:figure-counter-minor;}
  h1[data-number="88"]{counter-set:figure-counter-major 88;counter-reset:figure-counter-minor;}
  h1[data-number="89"]{counter-set:figure-counter-major 89;counter-reset:figure-counter-minor;}
  h1[data-number="90"]{counter-set:figure-counter-major 90;counter-reset:figure-counter-minor;}
  h1[data-number="91"]{counter-set:figure-counter-major 91;counter-reset:figure-counter-minor;}
  h1[data-number="92"]{counter-set:figure-counter-major 92;counter-reset:figure-counter-minor;}
  h1[data-number="93"]{counter-set:figure-counter-major 93;counter-reset:figure-counter-minor;}
  h1[data-number="94"]{counter-set:figure-counter-major 94;counter-reset:figure-counter-minor;}
  h1[data-number="95"]{counter-set:figure-counter-major 95;counter-reset:figure-counter-minor;}
  h1[data-number="96"]{counter-set:figure-counter-major 96;counter-reset:figure-counter-minor;}
  h1[data-number="97"]{counter-set:figure-counter-major 97;counter-reset:figure-counter-minor;}
  h1[data-number="98"]{counter-set:figure-counter-major 98;counter-reset:figure-counter-minor;}
  h1[data-number="99"]{counter-set:figure-counter-major 99;counter-reset:figure-counter-minor;}


  </style>
  <!-- BG custom styling for the wide body variant -->
  <!-- Gets appended after bg-css.html -->

  <style type="text/css">
  body {
      max-width: inherit;
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body>
<div style="text-align:center"><span><a href="date-and-time-functionality.html" rel="prev">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="chapter-atomics.html" rel="next">Next</a></span></div><hr>
<h1 data-number="39" id="multithreading"><span class="header-section-number">39</span> Multithreading</h1>
<p></p>
<p>C11 introduced, formally, multithreading to the C language. It’s very eerily similar to <a href="https://en.wikipedia.org/wiki/POSIX_Threads">POSIX threads</a><a href="function-specifiers-alignment-specifiersoperators.html#fn197" class="footnote-ref" id="fnref197" role="doc-noteref"><sup>197</sup></a>, if you’ve ever used those.</p>
<p>And if you’ve not, no worries. We’ll talk it through.</p>
<p>Do note, however, that I’m not intending this to be a full-blown classic multithreading how-to<a href="function-specifiers-alignment-specifiersoperators.html#fn198" class="footnote-ref" id="fnref198" role="doc-noteref"><sup>198</sup></a>; you’ll have to pick up a different very thick book for that, specifically. Sorry!</p>
<p></p>
<p>Threading is an optional feature. If a C11+ compiler defines <code>__STDC_NO_THREADS__</code>, threads will <strong>not</strong> be present in the library. Why they decided to go with a negative sense in that macro is beyond me, but there we are.</p>
<p>You can test for it like this:</p>
<div class="sourceCode" id="cb743"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb743-1"><a href="multithreading.html#cb743-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef __STDC_NO_THREADS__</span></span>
<span id="cb743-2"><a href="multithreading.html#cb743-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#error I need threads to build this program!</span></span>
<span id="cb743-3"><a href="multithreading.html#cb743-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p></p>
<p></p>
<p>Also, you might need to specify certain linker options when building. In the case of Unix-likes, try appending a <code>-lpthreads</code> to the end of the command line to link the <code>pthreads</code> library<a href="function-specifiers-alignment-specifiersoperators.html#fn199" class="footnote-ref" id="fnref199" role="doc-noteref"><sup>199</sup></a>:</p>
<div class="sourceCode" id="cb744"><pre class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb744-1"><a href="multithreading.html#cb744-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> <span class="at">-std</span><span class="op">=</span>c11 <span class="at">-o</span> foo foo.c <span class="at">-lpthreads</span></span></code></pre></div>
<p></p>
<p>If you’re getting linker errors on your system, it could be because the appropriate library wasn’t included.</p>
<h2 data-number="39.1" id="background"><span class="header-section-number">39.1</span> Background</h2>
<p>Threads are a way to have all those shiny CPU cores you paid for do work for you in the same program.</p>
<p>Normally, a C program just runs on a single CPU core. But if you know how to split up the work, you can give pieces of it to a number of threads and have them do the work simultaneously.</p>
<p>Though the spec doesn’t say it, on your system it’s very likely that C (or the OS at its behest) will attempt to balance the threads over all your CPU cores.</p>
<p>And if you have more threads than cores, that’s OK. You just won’t realize all those gains if they’re all trying to compete for CPU time.</p>
<h2 data-number="39.2" id="things-you-can-do"><span class="header-section-number">39.2</span> Things You Can Do</h2>
<p>You can create a thread. It will begin running the function you specify. The parent thread that spawned it will also continue to run.</p>
<p>And you can wait for the thread to complete. This is called <em>joining</em>.</p>
<p>Or if you don’t care when the thread completes and don’t want to wait, you can <em>detach it</em>.</p>
<p>A thread can explicitly <em>exit</em>, or it can implicitly call it quits by returning from its main function.</p>
<p>A thread can also <em>sleep</em> for a period of time, doing nothing while other threads run.</p>
<p>The <code>main()</code> program is a thread, as well.</p>
<p>Additionally, we have thread local storage, mutexes, and conditional variables. But more on those later. Let’s just look at the basics for now.</p>
<h2 data-number="39.3" id="data-races-and-the-standard-library"><span class="header-section-number">39.3</span> Data Races and the Standard Library</h2>
<p></p>
<p>Some of the functions in the standard library (e.g. <code>asctime()</code> and <code>strtok()</code>) return or use <code>static</code> data elements that aren’t threadsafe. But in general unless it’s said otherwise, the standard library makes an effort to be so<a href="function-specifiers-alignment-specifiersoperators.html#fn200" class="footnote-ref" id="fnref200" role="doc-noteref"><sup>200</sup></a>.</p>
<p>But keep an eye out. If a standard library function is maintaining state between calls in a variable you don’t own, or if a function is returning a pointer to a thing that you didn’t pass in, it’s not threadsafe.</p>
<p></p>
<h2 data-number="39.4" id="creating-and-waiting-for-threads"><span class="header-section-number">39.4</span> Creating and Waiting for Threads</h2>
<p>Let’s hack something up!</p>
<p>We’ll make some threads (create) and wait for them to complete (join).</p>
<p>We have a tiny bit to understand first, though.</p>
<p>Every single thread is identified by an opaque variable of type <code>thrd_t</code>. It’s a unique identifier per thread in your program. When you create a thread, it’s given a new ID.</p>
<p>Also when you make the thread, you have to give it a pointer to a function to run, and a pointer to an argument to pass to it (or <code>NULL</code> if you don’t have anything to pass).</p>
<p>The thread will begin execution on the function you specify.</p>
<p>When you want to wait for a thread to complete, you have to specify its thread ID so C knows which one to wait for.</p>
<p>So the basic idea is:</p>
<ol type="1">
<li>Write a function to act as the thread’s “<code>main</code>”. It’s not <code>main()</code>-proper, but analogous to it. The thread will start running there.</li>
<li>From the main thread, launch a new thread with <code>thrd_create()</code>, and pass it a pointer to the function to run.</li>
<li>In that function, have the thread do whatever it has to do.</li>
<li>Meantimes, the main thread can continue doing whatever <em>it</em> has to do.</li>
<li>When the main thread decides to, it can wait for the child thread to complete by calling <code>thrd_join()</code>. Generally you <strong>must</strong> <code>thrd_join()</code> the thread to clean up after it or else you’ll leak memory<a href="function-specifiers-alignment-specifiersoperators.html#fn201" class="footnote-ref" id="fnref201" role="doc-noteref"><sup>201</sup></a></li>
</ol>
<p> </p>
<p><code>thrd_create()</code> takes a pointer to the function to run, and it’s of type <code>thrd_start_t</code>, which is <code>int (*)(void *)</code>. That’s Greek for “a pointer to a function that takes an <code>void*</code> as an argument, and returns an <code>int</code>.”</p>
<p></p>
<p>Let’s make a thread! We’ll launch it from the main thread with <code>thrd_create()</code> to run a function, do some other things, then wait for it to complete with <code>thrd_join()</code>. I’ve named the thread’s main function <code>run()</code>, but you can name it anything as long as the types match <code>thrd_start_t</code>.</p>
<div class="sourceCode" id="cb745"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb745-1"><a href="multithreading.html#cb745-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb745-2"><a href="multithreading.html#cb745-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb745-3"><a href="multithreading.html#cb745-3"></a></span>
<span id="cb745-4"><a href="multithreading.html#cb745-4"></a><span class="co">// This is the function the thread will run. It can be called anything.</span></span>
<span id="cb745-5"><a href="multithreading.html#cb745-5"></a><span class="co">//</span></span>
<span id="cb745-6"><a href="multithreading.html#cb745-6"></a><span class="co">// arg is the argument pointer passed to `thrd_create()`.</span></span>
<span id="cb745-7"><a href="multithreading.html#cb745-7"></a><span class="co">//</span></span>
<span id="cb745-8"><a href="multithreading.html#cb745-8"></a><span class="co">// The parent thread will get the return value back from `thrd_join()`&#39;</span></span>
<span id="cb745-9"><a href="multithreading.html#cb745-9"></a><span class="co">// later.</span></span>
<span id="cb745-10"><a href="multithreading.html#cb745-10"></a></span>
<span id="cb745-11"><a href="multithreading.html#cb745-11"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb745-12"><a href="multithreading.html#cb745-12"></a><span class="op">{</span></span>
<span id="cb745-13"><a href="multithreading.html#cb745-13"></a>    <span class="dt">int</span> <span class="op">*</span>a <span class="op">=</span> arg<span class="op">;</span>  <span class="co">// We&#39;ll pass in an int* from thrd_create()</span></span>
<span id="cb745-14"><a href="multithreading.html#cb745-14"></a></span>
<span id="cb745-15"><a href="multithreading.html#cb745-15"></a>    printf<span class="op">(</span><span class="st">&quot;THREAD: Running thread with arg </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>a<span class="op">);</span></span>
<span id="cb745-16"><a href="multithreading.html#cb745-16"></a></span>
<span id="cb745-17"><a href="multithreading.html#cb745-17"></a>    <span class="cf">return</span> <span class="dv">12</span><span class="op">;</span>  <span class="co">// Value to be picked up by thrd_join() (chose 12 at random)</span></span>
<span id="cb745-18"><a href="multithreading.html#cb745-18"></a><span class="op">}</span></span>
<span id="cb745-19"><a href="multithreading.html#cb745-19"></a></span>
<span id="cb745-20"><a href="multithreading.html#cb745-20"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb745-21"><a href="multithreading.html#cb745-21"></a><span class="op">{</span></span>
<span id="cb745-22"><a href="multithreading.html#cb745-22"></a>    thrd_t t<span class="op">;</span>  <span class="co">// t will hold the thread ID</span></span>
<span id="cb745-23"><a href="multithreading.html#cb745-23"></a>    <span class="dt">int</span> arg <span class="op">=</span> <span class="dv">3490</span><span class="op">;</span></span>
<span id="cb745-24"><a href="multithreading.html#cb745-24"></a></span>
<span id="cb745-25"><a href="multithreading.html#cb745-25"></a>    printf<span class="op">(</span><span class="st">&quot;Launching a thread</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb745-26"><a href="multithreading.html#cb745-26"></a></span>
<span id="cb745-27"><a href="multithreading.html#cb745-27"></a>    <span class="co">// Launch a thread to the run() function, passing a pointer to 3490</span></span>
<span id="cb745-28"><a href="multithreading.html#cb745-28"></a>    <span class="co">// as an argument. Also stored the thread ID in t:</span></span>
<span id="cb745-29"><a href="multithreading.html#cb745-29"></a></span>
<span id="cb745-30"><a href="multithreading.html#cb745-30"></a>    thrd_create<span class="op">(&amp;</span>t<span class="op">,</span> run<span class="op">,</span> <span class="op">&amp;</span>arg<span class="op">);</span></span>
<span id="cb745-31"><a href="multithreading.html#cb745-31"></a></span>
<span id="cb745-32"><a href="multithreading.html#cb745-32"></a>    printf<span class="op">(</span><span class="st">&quot;Doing other things while the thread runs</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb745-33"><a href="multithreading.html#cb745-33"></a></span>
<span id="cb745-34"><a href="multithreading.html#cb745-34"></a>    printf<span class="op">(</span><span class="st">&quot;Waiting for thread to complete...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb745-35"><a href="multithreading.html#cb745-35"></a></span>
<span id="cb745-36"><a href="multithreading.html#cb745-36"></a>    <span class="dt">int</span> res<span class="op">;</span>  <span class="co">// Holds return value from the thread exit</span></span>
<span id="cb745-37"><a href="multithreading.html#cb745-37"></a></span>
<span id="cb745-38"><a href="multithreading.html#cb745-38"></a>    <span class="co">// Wait here for the thread to complete; store the return value</span></span>
<span id="cb745-39"><a href="multithreading.html#cb745-39"></a>    <span class="co">// in res:</span></span>
<span id="cb745-40"><a href="multithreading.html#cb745-40"></a></span>
<span id="cb745-41"><a href="multithreading.html#cb745-41"></a>    thrd_join<span class="op">(</span>t<span class="op">,</span> <span class="op">&amp;</span>res<span class="op">);</span></span>
<span id="cb745-42"><a href="multithreading.html#cb745-42"></a></span>
<span id="cb745-43"><a href="multithreading.html#cb745-43"></a>    printf<span class="op">(</span><span class="st">&quot;Thread exited with return value </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> res<span class="op">);</span></span>
<span id="cb745-44"><a href="multithreading.html#cb745-44"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>See how we did the <code>thrd_create()</code> there to call the <code>run()</code> function? Then we did other things in <code>main()</code> and then stopped and waited for the thread to complete with <code>thrd_join()</code>.</p>
<p> </p>
<p>Sample output (yours might vary):</p>
<div class="sourceCode" id="cb746"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb746-1"><a href="multithreading.html#cb746-1" aria-hidden="true" tabindex="-1"></a>Launching a thread</span>
<span id="cb746-2"><a href="multithreading.html#cb746-2" aria-hidden="true" tabindex="-1"></a>Doing other things while the thread runs</span>
<span id="cb746-3"><a href="multithreading.html#cb746-3" aria-hidden="true" tabindex="-1"></a>Waiting for thread to complete...</span>
<span id="cb746-4"><a href="multithreading.html#cb746-4" aria-hidden="true" tabindex="-1"></a>THREAD: Running thread with arg 3490</span>
<span id="cb746-5"><a href="multithreading.html#cb746-5" aria-hidden="true" tabindex="-1"></a>Thread exited with return value 12</span></code></pre></div>
<p>The <code>arg</code> that you pass to the function has to have a lifetime long enough so that the thread can pick it up before it goes away. Also, it needs to not be overwritten by the main thread before the new thread can use it.</p>
<p>Let’s look at an example that launches 5 threads. One thing to note here is how we use an array of <code>thrd_t</code>s to keep track of all the thread IDs.</p>
<p> </p>
<div class="sourceCode" id="cb747"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb747-1"><a href="multithreading.html#cb747-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb747-2"><a href="multithreading.html#cb747-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb747-3"><a href="multithreading.html#cb747-3"></a></span>
<span id="cb747-4"><a href="multithreading.html#cb747-4"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb747-5"><a href="multithreading.html#cb747-5"></a><span class="op">{</span></span>
<span id="cb747-6"><a href="multithreading.html#cb747-6"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="op">*(</span><span class="dt">int</span><span class="op">*)</span>arg<span class="op">;</span></span>
<span id="cb747-7"><a href="multithreading.html#cb747-7"></a></span>
<span id="cb747-8"><a href="multithreading.html#cb747-8"></a>    printf<span class="op">(</span><span class="st">&quot;THREAD </span><span class="sc">%d</span><span class="st">: running!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb747-9"><a href="multithreading.html#cb747-9"></a></span>
<span id="cb747-10"><a href="multithreading.html#cb747-10"></a>    <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb747-11"><a href="multithreading.html#cb747-11"></a><span class="op">}</span></span>
<span id="cb747-12"><a href="multithreading.html#cb747-12"></a></span>
<span id="cb747-13"><a href="multithreading.html#cb747-13"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">5</span></span>
<span id="cb747-14"><a href="multithreading.html#cb747-14"></a></span>
<span id="cb747-15"><a href="multithreading.html#cb747-15"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb747-16"><a href="multithreading.html#cb747-16"></a><span class="op">{</span></span>
<span id="cb747-17"><a href="multithreading.html#cb747-17"></a>    thrd_t t<span class="op">[</span>THREAD_COUNT<span class="op">];</span></span>
<span id="cb747-18"><a href="multithreading.html#cb747-18"></a></span>
<span id="cb747-19"><a href="multithreading.html#cb747-19"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb747-20"><a href="multithreading.html#cb747-20"></a></span>
<span id="cb747-21"><a href="multithreading.html#cb747-21"></a>    printf<span class="op">(</span><span class="st">&quot;Launching threads...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb747-22"><a href="multithreading.html#cb747-22"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb747-23"><a href="multithreading.html#cb747-23"></a></span>
<span id="cb747-24"><a href="multithreading.html#cb747-24"></a>        <span class="co">// </span><span class="al">NOTE</span><span class="co">! In the following line, we pass a pointer to i, </span></span>
<span id="cb747-25"><a href="multithreading.html#cb747-25"></a>        <span class="co">// but each thread sees the same pointer. So they&#39;ll</span></span>
<span id="cb747-26"><a href="multithreading.html#cb747-26"></a>        <span class="co">// print out weird things as i changes value here in</span></span>
<span id="cb747-27"><a href="multithreading.html#cb747-27"></a>        <span class="co">// the main thread! (More in the text, below.)</span></span>
<span id="cb747-28"><a href="multithreading.html#cb747-28"></a></span>
<span id="cb747-29"><a href="multithreading.html#cb747-29"></a>        thrd_create<span class="op">(</span>t <span class="op">+</span> i<span class="op">,</span> run<span class="op">,</span> <span class="op">&amp;</span>i<span class="op">);</span></span>
<span id="cb747-30"><a href="multithreading.html#cb747-30"></a></span>
<span id="cb747-31"><a href="multithreading.html#cb747-31"></a>    printf<span class="op">(</span><span class="st">&quot;Doing other things while the thread runs...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb747-32"><a href="multithreading.html#cb747-32"></a>    printf<span class="op">(</span><span class="st">&quot;Waiting for thread to complete...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb747-33"><a href="multithreading.html#cb747-33"></a></span>
<span id="cb747-34"><a href="multithreading.html#cb747-34"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb747-35"><a href="multithreading.html#cb747-35"></a>        <span class="dt">int</span> res<span class="op">;</span></span>
<span id="cb747-36"><a href="multithreading.html#cb747-36"></a>        thrd_join<span class="op">(</span>t<span class="op">[</span>i<span class="op">],</span> <span class="op">&amp;</span>res<span class="op">);</span></span>
<span id="cb747-37"><a href="multithreading.html#cb747-37"></a></span>
<span id="cb747-38"><a href="multithreading.html#cb747-38"></a>        printf<span class="op">(</span><span class="st">&quot;Thread </span><span class="sc">%d</span><span class="st"> complete!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> res<span class="op">);</span></span>
<span id="cb747-39"><a href="multithreading.html#cb747-39"></a>    <span class="op">}</span></span>
<span id="cb747-40"><a href="multithreading.html#cb747-40"></a></span>
<span id="cb747-41"><a href="multithreading.html#cb747-41"></a>    printf<span class="op">(</span><span class="st">&quot;All threads complete!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb747-42"><a href="multithreading.html#cb747-42"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>When I run the threads, I count <code>i</code> up from 0 to 4. And pass a pointer to it to <code>thrd_create()</code>. This pointer ends up in the <code>run()</code> routine where we make a copy of it.</p>
<p></p>
<p>Simple enough? Here’s the output:</p>
<div class="sourceCode" id="cb748"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb748-1"><a href="multithreading.html#cb748-1" aria-hidden="true" tabindex="-1"></a>Launching threads...</span>
<span id="cb748-2"><a href="multithreading.html#cb748-2" aria-hidden="true" tabindex="-1"></a>THREAD 2: running!</span>
<span id="cb748-3"><a href="multithreading.html#cb748-3" aria-hidden="true" tabindex="-1"></a>THREAD 3: running!</span>
<span id="cb748-4"><a href="multithreading.html#cb748-4" aria-hidden="true" tabindex="-1"></a>THREAD 4: running!</span>
<span id="cb748-5"><a href="multithreading.html#cb748-5" aria-hidden="true" tabindex="-1"></a>THREAD 2: running!</span>
<span id="cb748-6"><a href="multithreading.html#cb748-6" aria-hidden="true" tabindex="-1"></a>Doing other things while the thread runs...</span>
<span id="cb748-7"><a href="multithreading.html#cb748-7" aria-hidden="true" tabindex="-1"></a>Waiting for thread to complete...</span>
<span id="cb748-8"><a href="multithreading.html#cb748-8" aria-hidden="true" tabindex="-1"></a>Thread 2 complete!</span>
<span id="cb748-9"><a href="multithreading.html#cb748-9" aria-hidden="true" tabindex="-1"></a>Thread 2 complete!</span>
<span id="cb748-10"><a href="multithreading.html#cb748-10" aria-hidden="true" tabindex="-1"></a>THREAD 5: running!</span>
<span id="cb748-11"><a href="multithreading.html#cb748-11" aria-hidden="true" tabindex="-1"></a>Thread 3 complete!</span>
<span id="cb748-12"><a href="multithreading.html#cb748-12" aria-hidden="true" tabindex="-1"></a>Thread 4 complete!</span>
<span id="cb748-13"><a href="multithreading.html#cb748-13" aria-hidden="true" tabindex="-1"></a>Thread 5 complete!</span>
<span id="cb748-14"><a href="multithreading.html#cb748-14" aria-hidden="true" tabindex="-1"></a>All threads complete!</span></code></pre></div>
<p>Whaaa—? Where’s <code>THREAD 0</code>? And why do we have a <code>THREAD 5</code> when clearly <code>i</code> is never more than <code>4</code> when we call <code>thrd_create()</code>? And two <code>THREAD 2</code>s? Madness!</p>
<p>This is getting into the fun land of <em>race conditions</em>. The main thread is modifying <code>i</code> before the thread has a chance to copy it. Indeed, <code>i</code> makes it all the way to <code>5</code> and ends the loop before the last thread gets a chance to copy it.</p>
<p>We’ve got to have a per-thread variable that we can refer to so we can pass it in as the <code>arg</code>.</p>
<p>We could have a big array of them. Or we could <code>malloc()</code> space (and free it somewhere—maybe in the thread itself.)</p>
<p>Let’s give that a shot:</p>
<div class="sourceCode" id="cb749"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb749-1"><a href="multithreading.html#cb749-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb749-2"><a href="multithreading.html#cb749-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb749-3"><a href="multithreading.html#cb749-3"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb749-4"><a href="multithreading.html#cb749-4"></a></span>
<span id="cb749-5"><a href="multithreading.html#cb749-5"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb749-6"><a href="multithreading.html#cb749-6"></a><span class="op">{</span></span>
<span id="cb749-7"><a href="multithreading.html#cb749-7"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="op">*(</span><span class="dt">int</span><span class="op">*)</span>arg<span class="op">;</span>  <span class="co">// Copy the arg</span></span>
<span id="cb749-8"><a href="multithreading.html#cb749-8"></a></span>
<span id="cb749-9"><a href="multithreading.html#cb749-9"></a>    free<span class="op">(</span>arg<span class="op">);</span>  <span class="co">// Done with this</span></span>
<span id="cb749-10"><a href="multithreading.html#cb749-10"></a></span>
<span id="cb749-11"><a href="multithreading.html#cb749-11"></a>    printf<span class="op">(</span><span class="st">&quot;THREAD </span><span class="sc">%d</span><span class="st">: running!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb749-12"><a href="multithreading.html#cb749-12"></a></span>
<span id="cb749-13"><a href="multithreading.html#cb749-13"></a>    <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb749-14"><a href="multithreading.html#cb749-14"></a><span class="op">}</span></span>
<span id="cb749-15"><a href="multithreading.html#cb749-15"></a></span>
<span id="cb749-16"><a href="multithreading.html#cb749-16"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">5</span></span>
<span id="cb749-17"><a href="multithreading.html#cb749-17"></a></span>
<span id="cb749-18"><a href="multithreading.html#cb749-18"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb749-19"><a href="multithreading.html#cb749-19"></a><span class="op">{</span></span>
<span id="cb749-20"><a href="multithreading.html#cb749-20"></a>    thrd_t t<span class="op">[</span>THREAD_COUNT<span class="op">];</span></span>
<span id="cb749-21"><a href="multithreading.html#cb749-21"></a></span>
<span id="cb749-22"><a href="multithreading.html#cb749-22"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb749-23"><a href="multithreading.html#cb749-23"></a></span>
<span id="cb749-24"><a href="multithreading.html#cb749-24"></a>    printf<span class="op">(</span><span class="st">&quot;Launching threads...</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb749-25"><a href="multithreading.html#cb749-25"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb749-26"><a href="multithreading.html#cb749-26"></a></span>
<span id="cb749-27"><a href="multithreading.html#cb749-27"></a>        <span class="co">// Get some space for a per-thread argument:</span></span>
<span id="cb749-28"><a href="multithreading.html#cb749-28"></a></span>
<span id="cb749-29"><a href="multithreading.html#cb749-29"></a>        <span class="dt">int</span> <span class="op">*</span>arg <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span> <span class="op">*</span>arg<span class="op">);</span></span>
<span id="cb749-30"><a href="multithreading.html#cb749-30"></a>        <span class="op">*</span>arg <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb749-31"><a href="multithreading.html#cb749-31"></a></span>
<span id="cb749-32"><a href="multithreading.html#cb749-32"></a>        thrd_create<span class="op">(</span>t <span class="op">+</span> i<span class="op">,</span> run<span class="op">,</span> arg<span class="op">);</span></span>
<span id="cb749-33"><a href="multithreading.html#cb749-33"></a>    <span class="op">}</span></span>
<span id="cb749-34"><a href="multithreading.html#cb749-34"></a></span>
<span id="cb749-35"><a href="multithreading.html#cb749-35"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>Notice on lines 27-30 we <code>malloc()</code> space for an <code>int</code> and copy the value of <code>i</code> into it. Each new thread gets its own freshly-<code>malloc()</code>d variable and we pass a pointer to that to the <code>run()</code> function.</p>
<p>Once <code>run()</code> makes its own copy of the <code>arg</code> on line 7, it <code>free()</code>s the <code>malloc()</code>d <code>int</code>. And now that it has its own copy, it can do with it what it pleases.</p>
<p>And a run shows the result:</p>
<div class="sourceCode" id="cb750"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb750-1"><a href="multithreading.html#cb750-1" aria-hidden="true" tabindex="-1"></a>Launching threads...</span>
<span id="cb750-2"><a href="multithreading.html#cb750-2" aria-hidden="true" tabindex="-1"></a>THREAD 0: running!</span>
<span id="cb750-3"><a href="multithreading.html#cb750-3" aria-hidden="true" tabindex="-1"></a>THREAD 1: running!</span>
<span id="cb750-4"><a href="multithreading.html#cb750-4" aria-hidden="true" tabindex="-1"></a>THREAD 2: running!</span>
<span id="cb750-5"><a href="multithreading.html#cb750-5" aria-hidden="true" tabindex="-1"></a>THREAD 3: running!</span>
<span id="cb750-6"><a href="multithreading.html#cb750-6" aria-hidden="true" tabindex="-1"></a>Doing other things while the thread runs...</span>
<span id="cb750-7"><a href="multithreading.html#cb750-7" aria-hidden="true" tabindex="-1"></a>Waiting for thread to complete...</span>
<span id="cb750-8"><a href="multithreading.html#cb750-8" aria-hidden="true" tabindex="-1"></a>Thread 0 complete!</span>
<span id="cb750-9"><a href="multithreading.html#cb750-9" aria-hidden="true" tabindex="-1"></a>Thread 1 complete!</span>
<span id="cb750-10"><a href="multithreading.html#cb750-10" aria-hidden="true" tabindex="-1"></a>Thread 2 complete!</span>
<span id="cb750-11"><a href="multithreading.html#cb750-11" aria-hidden="true" tabindex="-1"></a>Thread 3 complete!</span>
<span id="cb750-12"><a href="multithreading.html#cb750-12" aria-hidden="true" tabindex="-1"></a>THREAD 4: running!</span>
<span id="cb750-13"><a href="multithreading.html#cb750-13" aria-hidden="true" tabindex="-1"></a>Thread 4 complete!</span>
<span id="cb750-14"><a href="multithreading.html#cb750-14" aria-hidden="true" tabindex="-1"></a>All threads complete!</span></code></pre></div>
<p>There we go! Threads 0-4 all in effect!</p>
<p>Your run might vary—how the threads get scheduled to run is beyond the C spec. We see in the above example that thread 4 didn’t even begin until threads 0-1 had completed. Indeed, if I run this again, I likely get different output. We cannot guarantee a thread execution order.</p>
<h2 data-number="39.5" id="detaching-threads"><span class="header-section-number">39.5</span> Detaching Threads</h2>
<p>If you want to fire-and-forget a thread (i.e. so you don’t have to <code>thrd_join()</code> it later), you can do that with <code>thrd_detach()</code>.</p>
<p>This removes the parent thread’s ability to get the return value from the child thread, but if you don’t care about that and just want threads to clean up nicely on their own, this is the way to go.</p>
<p>Basically we’re going to do this:</p>
<p></p>
<div class="sourceCode" id="cb751"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb751-1"><a href="multithreading.html#cb751-1" aria-hidden="true" tabindex="-1"></a>thrd_create<span class="op">(&amp;</span>t<span class="op">,</span> run<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb751-2"><a href="multithreading.html#cb751-2" aria-hidden="true" tabindex="-1"></a>thrd_detach<span class="op">(</span>t<span class="op">);</span></span></code></pre></div>
<p>where the <code>thrd_detach()</code> call is the parent thread saying, “Hey, I’m not going to wait for this child thread to complete with <code>thrd_join()</code>. So go ahead and clean it up on your own when it completes.”</p>
<div class="sourceCode" id="cb752"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb752-1"><a href="multithreading.html#cb752-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb752-2"><a href="multithreading.html#cb752-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb752-3"><a href="multithreading.html#cb752-3"></a></span>
<span id="cb752-4"><a href="multithreading.html#cb752-4"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb752-5"><a href="multithreading.html#cb752-5"></a><span class="op">{</span></span>
<span id="cb752-6"><a href="multithreading.html#cb752-6"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>arg<span class="op">;</span></span>
<span id="cb752-7"><a href="multithreading.html#cb752-7"></a></span>
<span id="cb752-8"><a href="multithreading.html#cb752-8"></a>    <span class="co">//printf(&quot;Thread running! %lu\n&quot;, thrd_current()); // non-portable!</span></span>
<span id="cb752-9"><a href="multithreading.html#cb752-9"></a>    printf<span class="op">(</span><span class="st">&quot;Thread running!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb752-10"><a href="multithreading.html#cb752-10"></a></span>
<span id="cb752-11"><a href="multithreading.html#cb752-11"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb752-12"><a href="multithreading.html#cb752-12"></a><span class="op">}</span></span>
<span id="cb752-13"><a href="multithreading.html#cb752-13"></a></span>
<span id="cb752-14"><a href="multithreading.html#cb752-14"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">10</span></span>
<span id="cb752-15"><a href="multithreading.html#cb752-15"></a></span>
<span id="cb752-16"><a href="multithreading.html#cb752-16"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb752-17"><a href="multithreading.html#cb752-17"></a><span class="op">{</span></span>
<span id="cb752-18"><a href="multithreading.html#cb752-18"></a>    thrd_t t<span class="op">;</span></span>
<span id="cb752-19"><a href="multithreading.html#cb752-19"></a></span>
<span id="cb752-20"><a href="multithreading.html#cb752-20"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb752-21"><a href="multithreading.html#cb752-21"></a>        thrd_create<span class="op">(&amp;</span>t<span class="op">,</span> run<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb752-22"><a href="multithreading.html#cb752-22"></a>        thrd_detach<span class="op">(</span>t<span class="op">);</span>               <span class="co">// &lt;-- DETACH!</span></span>
<span id="cb752-23"><a href="multithreading.html#cb752-23"></a>    <span class="op">}</span></span>
<span id="cb752-24"><a href="multithreading.html#cb752-24"></a></span>
<span id="cb752-25"><a href="multithreading.html#cb752-25"></a>    <span class="co">// Sleep for a second to let all the threads finish</span></span>
<span id="cb752-26"><a href="multithreading.html#cb752-26"></a>    thrd_sleep<span class="op">(&amp;(</span><span class="kw">struct</span> timespec<span class="op">){.</span>tv_sec<span class="op">=</span><span class="dv">1</span><span class="op">},</span> NULL<span class="op">);</span></span>
<span id="cb752-27"><a href="multithreading.html#cb752-27"></a><span class="op">}</span></span></code></pre></div>
<p></p>
<p>Note that in this code, we put the main thread to sleep for 1 second with <code>thrd_sleep()</code>—more on that later.</p>
<p>Also in the <code>run()</code> function, I have a commented-out line in there that prints out the thread ID as an <code>unsigned long</code>. This is non-portable, because the spec doesn’t say what type a <code>thrd_t</code> is under the hood—it could be a <code>struct</code> for all we know. But that line works on my system.</p>
<p>Something interesting I saw when I ran the code, above, and printed out the thread IDs was that some threads had duplicate IDs! This seems like it should be impossible, but C is allowed to <em>reuse</em> thread IDs after the corresponding thread has exited. So what I was seeing was that some threads completed their run before other threads were launched.</p>
<h2 data-number="39.6" id="thread-local-data"><span class="header-section-number">39.6</span> Thread Local Data</h2>
<p></p>
<p>Threads are interesting because they don’t have their own memory beyond local variables. If you want a <code>static</code> variable or file scope variable, all threads will see that same variable.</p>
<p>This can lead to race conditions, where you get <em>Weird Things</em>™ happening.</p>
<p>Check out this example. We have a <code>static</code> variable <code>foo</code> in block scope in <code>run()</code>. This variable will be visible to all threads that pass through the <code>run()</code> function. And the various threads can effectively step on each others toes.</p>
<p>Each thread copies <code>foo</code> into a local variable <code>x</code> (which is not shared between threads—all the threads have their own call stacks). So they <em>should</em> be the same, right?</p>
<p>And the first time we print them, they are<a href="function-specifiers-alignment-specifiersoperators.html#fn202" class="footnote-ref" id="fnref202" role="doc-noteref"><sup>202</sup></a>. But then right after that, we check to make sure they’re still the same.</p>
<p>And they <em>usually</em> are. But not always!</p>
<div class="sourceCode" id="cb753"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb753-1"><a href="multithreading.html#cb753-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb753-2"><a href="multithreading.html#cb753-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb753-3"><a href="multithreading.html#cb753-3"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb753-4"><a href="multithreading.html#cb753-4"></a></span>
<span id="cb753-5"><a href="multithreading.html#cb753-5"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb753-6"><a href="multithreading.html#cb753-6"></a><span class="op">{</span></span>
<span id="cb753-7"><a href="multithreading.html#cb753-7"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="op">*(</span><span class="dt">int</span><span class="op">*)</span>arg<span class="op">;</span>  <span class="co">// Thread number for humans to differentiate</span></span>
<span id="cb753-8"><a href="multithreading.html#cb753-8"></a></span>
<span id="cb753-9"><a href="multithreading.html#cb753-9"></a>    free<span class="op">(</span>arg<span class="op">);</span></span>
<span id="cb753-10"><a href="multithreading.html#cb753-10"></a></span>
<span id="cb753-11"><a href="multithreading.html#cb753-11"></a>    <span class="dt">static</span> <span class="dt">int</span> foo <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// Static value shared between threads</span></span>
<span id="cb753-12"><a href="multithreading.html#cb753-12"></a></span>
<span id="cb753-13"><a href="multithreading.html#cb753-13"></a>    <span class="dt">int</span> x <span class="op">=</span> foo<span class="op">;</span>  <span class="co">// Automatic local variable--each thread has its own</span></span>
<span id="cb753-14"><a href="multithreading.html#cb753-14"></a></span>
<span id="cb753-15"><a href="multithreading.html#cb753-15"></a>    <span class="co">// We just assigned x from foo, so they&#39;d better be equal here.</span></span>
<span id="cb753-16"><a href="multithreading.html#cb753-16"></a>    <span class="co">// (In all my test runs, they were, but even this isn&#39;t guaranteed!)</span></span>
<span id="cb753-17"><a href="multithreading.html#cb753-17"></a></span>
<span id="cb753-18"><a href="multithreading.html#cb753-18"></a>    printf<span class="op">(</span><span class="st">&quot;Thread </span><span class="sc">%d</span><span class="st">: x = </span><span class="sc">%d</span><span class="st">, foo = </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> n<span class="op">,</span> x<span class="op">,</span> foo<span class="op">);</span></span>
<span id="cb753-19"><a href="multithreading.html#cb753-19"></a></span>
<span id="cb753-20"><a href="multithreading.html#cb753-20"></a>    <span class="co">// And they should be equal here, but they&#39;re not always!</span></span>
<span id="cb753-21"><a href="multithreading.html#cb753-21"></a>    <span class="co">// (Sometimes they were, sometimes they weren&#39;t!)</span></span>
<span id="cb753-22"><a href="multithreading.html#cb753-22"></a></span>
<span id="cb753-23"><a href="multithreading.html#cb753-23"></a>    <span class="co">// What happens is another thread gets in and increments foo</span></span>
<span id="cb753-24"><a href="multithreading.html#cb753-24"></a>    <span class="co">// right now, but this thread&#39;s x remains what it was before!</span></span>
<span id="cb753-25"><a href="multithreading.html#cb753-25"></a></span>
<span id="cb753-26"><a href="multithreading.html#cb753-26"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">!=</span> foo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb753-27"><a href="multithreading.html#cb753-27"></a>        printf<span class="op">(</span><span class="st">&quot;Thread </span><span class="sc">%d</span><span class="st">: Craziness! x != foo! </span><span class="sc">%d</span><span class="st"> != </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> n<span class="op">,</span> x<span class="op">,</span> foo<span class="op">);</span></span>
<span id="cb753-28"><a href="multithreading.html#cb753-28"></a>    <span class="op">}</span></span>
<span id="cb753-29"><a href="multithreading.html#cb753-29"></a></span>
<span id="cb753-30"><a href="multithreading.html#cb753-30"></a>    foo<span class="op">++;</span>  <span class="co">// Increment shared value</span></span>
<span id="cb753-31"><a href="multithreading.html#cb753-31"></a></span>
<span id="cb753-32"><a href="multithreading.html#cb753-32"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb753-33"><a href="multithreading.html#cb753-33"></a><span class="op">}</span></span>
<span id="cb753-34"><a href="multithreading.html#cb753-34"></a></span>
<span id="cb753-35"><a href="multithreading.html#cb753-35"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">5</span></span>
<span id="cb753-36"><a href="multithreading.html#cb753-36"></a></span>
<span id="cb753-37"><a href="multithreading.html#cb753-37"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb753-38"><a href="multithreading.html#cb753-38"></a><span class="op">{</span></span>
<span id="cb753-39"><a href="multithreading.html#cb753-39"></a>    thrd_t t<span class="op">[</span>THREAD_COUNT<span class="op">];</span></span>
<span id="cb753-40"><a href="multithreading.html#cb753-40"></a></span>
<span id="cb753-41"><a href="multithreading.html#cb753-41"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb753-42"><a href="multithreading.html#cb753-42"></a>        <span class="dt">int</span> <span class="op">*</span>n <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span> <span class="op">*</span>n<span class="op">);</span>  <span class="co">// Holds a thread serial number</span></span>
<span id="cb753-43"><a href="multithreading.html#cb753-43"></a>        <span class="op">*</span>n <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb753-44"><a href="multithreading.html#cb753-44"></a>        thrd_create<span class="op">(</span>t <span class="op">+</span> i<span class="op">,</span> run<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb753-45"><a href="multithreading.html#cb753-45"></a>    <span class="op">}</span></span>
<span id="cb753-46"><a href="multithreading.html#cb753-46"></a></span>
<span id="cb753-47"><a href="multithreading.html#cb753-47"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb753-48"><a href="multithreading.html#cb753-48"></a>        thrd_join<span class="op">(</span>t<span class="op">[</span>i<span class="op">],</span> NULL<span class="op">);</span></span>
<span id="cb753-49"><a href="multithreading.html#cb753-49"></a>    <span class="op">}</span></span>
<span id="cb753-50"><a href="multithreading.html#cb753-50"></a><span class="op">}</span></span></code></pre></div>
<p>Here’s an example output (though this varies from run to run):</p>
<div class="sourceCode" id="cb754"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb754-1"><a href="multithreading.html#cb754-1" aria-hidden="true" tabindex="-1"></a>Thread 0: x = 10, foo = 10</span>
<span id="cb754-2"><a href="multithreading.html#cb754-2" aria-hidden="true" tabindex="-1"></a>Thread 1: x = 10, foo = 10</span>
<span id="cb754-3"><a href="multithreading.html#cb754-3" aria-hidden="true" tabindex="-1"></a>Thread 1: Craziness! x != foo! 10 != 11</span>
<span id="cb754-4"><a href="multithreading.html#cb754-4" aria-hidden="true" tabindex="-1"></a>Thread 2: x = 12, foo = 12</span>
<span id="cb754-5"><a href="multithreading.html#cb754-5" aria-hidden="true" tabindex="-1"></a>Thread 4: x = 13, foo = 13</span>
<span id="cb754-6"><a href="multithreading.html#cb754-6" aria-hidden="true" tabindex="-1"></a>Thread 3: x = 14, foo = 14</span></code></pre></div>
<p>In thread 1, between the two <code>printf()</code>s, the value of <code>foo</code> somehow changed from <code>10</code> to <code>11</code>, even though clearly there’s no increment between the <code>printf()</code>s!</p>
<p>It was another thread that got in there (probably thread 0, from the look of it) and incremented the value of <code>foo</code> behind thread 1’s back!</p>
<p>Let’s solve this problem two different ways. (If you want all the threads to share the variable <em>and</em> not step on each other’s toes, you’ll have to read on to the <a href="multithreading.html#mutex">mutex</a> section.)</p>
<h3 data-number="39.6.1" id="thread-local"><span class="header-section-number">39.6.1</span> <code>_Thread_local</code> Storage-Class</h3>
<p></p>
<p>First things first, let’s just look at the easy way around this: the <code>_Thread_local</code> storage-class.</p>
<p>Basically we’re just going to slap this on the front of our block scope <code>static</code> variable and things will work! It tells C that every thread should have its own version of this variable, so none of them step on each other’s toes.</p>
<p></p>
<p>The <code>&lt;threads.h&gt;</code> header defines <code>thread_local</code> as an alias to <code>_Thread_local</code> so your code doesn’t have to look so ugly.</p>
<p>Let’s take the previous example and make <code>foo</code> into a <code>thread_local</code> variable so that we don’t share that data.</p>
<div class="sourceCode" id="cb755" data-startfrom="5"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 4;"><span id="cb755-5"><a href="multithreading.html#cb755-5"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb755-6"><a href="multithreading.html#cb755-6"></a><span class="op">{</span></span>
<span id="cb755-7"><a href="multithreading.html#cb755-7"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="op">*(</span><span class="dt">int</span><span class="op">*)</span>arg<span class="op">;</span>  <span class="co">// Thread number for humans to differentiate</span></span>
<span id="cb755-8"><a href="multithreading.html#cb755-8"></a></span>
<span id="cb755-9"><a href="multithreading.html#cb755-9"></a>    free<span class="op">(</span>arg<span class="op">);</span></span>
<span id="cb755-10"><a href="multithreading.html#cb755-10"></a></span>
<span id="cb755-11"><a href="multithreading.html#cb755-11"></a>    <span class="dt">thread_local</span> <span class="dt">static</span> <span class="dt">int</span> foo <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// &lt;-- No longer shared!!</span></span></code></pre></div>
<p>And running we get:</p>
<div class="sourceCode" id="cb756"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb756-1"><a href="multithreading.html#cb756-1" aria-hidden="true" tabindex="-1"></a>Thread 0: x = 10, foo = 10</span>
<span id="cb756-2"><a href="multithreading.html#cb756-2" aria-hidden="true" tabindex="-1"></a>Thread 1: x = 10, foo = 10</span>
<span id="cb756-3"><a href="multithreading.html#cb756-3" aria-hidden="true" tabindex="-1"></a>Thread 2: x = 10, foo = 10</span>
<span id="cb756-4"><a href="multithreading.html#cb756-4" aria-hidden="true" tabindex="-1"></a>Thread 4: x = 10, foo = 10</span>
<span id="cb756-5"><a href="multithreading.html#cb756-5" aria-hidden="true" tabindex="-1"></a>Thread 3: x = 10, foo = 10</span></code></pre></div>
<p>No more weird problems!</p>
<p>One thing: if a <code>thread_local</code> variable is block scope, it <strong>must</strong> be <code>static</code>. Them’s the rules. (But this is OK because non-<code>static</code> variables are per-thread already since each thread has it’s own non-<code>static</code> variables.)</p>
<p>A bit of a lie there: block scope <code>thread_local</code> variables can also be <code>extern</code>.</p>
<p> </p>
<h3 data-number="39.6.2" id="another-option-thread-specific-storage"><span class="header-section-number">39.6.2</span> Another Option: Thread-Specific Storage</h3>
<p></p>
<p>Thread-specific storage (TSS) is another way of getting per-thread data.</p>
<p>One additional feature is that these functions allow you to specify a destructor that will be called on the data when the TSS variable is deleted. Commonly this destructor is <code>free()</code> to automatically clean up <code>malloc()</code>d per-thread data. Or <code>NULL</code> if you don’t need to destroy anything.</p>
<p>The destructor is type <code>tss_dtor_t</code> which is a pointer to a function that returns <code>void</code> and takes a <code>void*</code> as an argument (the <code>void*</code> points to the data stored in the variable). In other words, it’s a <code>void (*)(void*)</code>, if that clears it up. Which I admit it probably doesn’t. Check out the example, below.</p>
<p>Generally, <code>thread_local</code> is probably your go-to, but if you like the destructor idea, then you can make use of that.</p>
<p>The usage is a bit weird in that we need a variable of type <code>tss_t</code> to be alive to represent the value on a per thread basis. Then we initialize it with <code>tss_create()</code>. Eventually we get rid of it with <code>tss_delete()</code>. Note that calling <code>tss_delete()</code> doesn’t run all the destructors—it’s <code>thrd_exit()</code> (or returning from the run function) that does that. <code>tss_delete()</code> just releases any memory allocated by <code>tss_create()</code>. </p>
<p>In the middle, threads can call <code>tss_set()</code> and <code>tss_get()</code> to set and get the value.</p>
<p>In the following code, we set up the TSS variable before creating the threads, then clean up after the threads.</p>
<p>In the <code>run()</code> function, the threads <code>malloc()</code> some space for a string and store that pointer in the TSS variable.</p>
<p>When the thread exits, the destructor function (<code>free()</code> in this case) is called for <em>all</em> the threads.</p>
<p> </p>
<div class="sourceCode" id="cb757"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb757-1"><a href="multithreading.html#cb757-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb757-2"><a href="multithreading.html#cb757-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb757-3"><a href="multithreading.html#cb757-3"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb757-4"><a href="multithreading.html#cb757-4"></a></span>
<span id="cb757-5"><a href="multithreading.html#cb757-5"></a>tss_t str<span class="op">;</span></span>
<span id="cb757-6"><a href="multithreading.html#cb757-6"></a></span>
<span id="cb757-7"><a href="multithreading.html#cb757-7"></a><span class="dt">void</span> some_function<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb757-8"><a href="multithreading.html#cb757-8"></a><span class="op">{</span></span>
<span id="cb757-9"><a href="multithreading.html#cb757-9"></a>    <span class="co">// Retrieve the per-thread value of this string</span></span>
<span id="cb757-10"><a href="multithreading.html#cb757-10"></a>    <span class="dt">char</span> <span class="op">*</span>tss_string <span class="op">=</span> tss_get<span class="op">(</span>str<span class="op">);</span></span>
<span id="cb757-11"><a href="multithreading.html#cb757-11"></a></span>
<span id="cb757-12"><a href="multithreading.html#cb757-12"></a>    <span class="co">// And print it</span></span>
<span id="cb757-13"><a href="multithreading.html#cb757-13"></a>    printf<span class="op">(</span><span class="st">&quot;TSS string: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> tss_string<span class="op">);</span></span>
<span id="cb757-14"><a href="multithreading.html#cb757-14"></a><span class="op">}</span></span>
<span id="cb757-15"><a href="multithreading.html#cb757-15"></a></span>
<span id="cb757-16"><a href="multithreading.html#cb757-16"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb757-17"><a href="multithreading.html#cb757-17"></a><span class="op">{</span></span>
<span id="cb757-18"><a href="multithreading.html#cb757-18"></a>    <span class="dt">int</span> serial <span class="op">=</span> <span class="op">*(</span><span class="dt">int</span><span class="op">*)</span>arg<span class="op">;</span>  <span class="co">// Get this thread&#39;s serial number</span></span>
<span id="cb757-19"><a href="multithreading.html#cb757-19"></a>    free<span class="op">(</span>arg<span class="op">);</span></span>
<span id="cb757-20"><a href="multithreading.html#cb757-20"></a></span>
<span id="cb757-21"><a href="multithreading.html#cb757-21"></a>    <span class="co">// malloc() space to hold the data for this thread</span></span>
<span id="cb757-22"><a href="multithreading.html#cb757-22"></a>    <span class="dt">char</span> <span class="op">*</span>s <span class="op">=</span> malloc<span class="op">(</span><span class="dv">64</span><span class="op">);</span></span>
<span id="cb757-23"><a href="multithreading.html#cb757-23"></a>    sprintf<span class="op">(</span>s<span class="op">,</span> <span class="st">&quot;thread </span><span class="sc">%d</span><span class="st">! :)&quot;</span><span class="op">,</span> serial<span class="op">);</span>  <span class="co">// Happy little string</span></span>
<span id="cb757-24"><a href="multithreading.html#cb757-24"></a></span>
<span id="cb757-25"><a href="multithreading.html#cb757-25"></a>    <span class="co">// Set this TSS variable to point at the string</span></span>
<span id="cb757-26"><a href="multithreading.html#cb757-26"></a>    tss_set<span class="op">(</span>str<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb757-27"><a href="multithreading.html#cb757-27"></a></span>
<span id="cb757-28"><a href="multithreading.html#cb757-28"></a>    <span class="co">// Call a function that will get the variable</span></span>
<span id="cb757-29"><a href="multithreading.html#cb757-29"></a>    some_function<span class="op">();</span></span>
<span id="cb757-30"><a href="multithreading.html#cb757-30"></a></span>
<span id="cb757-31"><a href="multithreading.html#cb757-31"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>   <span class="co">// Equivalent to thrd_exit(0)</span></span>
<span id="cb757-32"><a href="multithreading.html#cb757-32"></a><span class="op">}</span></span>
<span id="cb757-33"><a href="multithreading.html#cb757-33"></a></span>
<span id="cb757-34"><a href="multithreading.html#cb757-34"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">15</span></span>
<span id="cb757-35"><a href="multithreading.html#cb757-35"></a></span>
<span id="cb757-36"><a href="multithreading.html#cb757-36"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb757-37"><a href="multithreading.html#cb757-37"></a><span class="op">{</span></span>
<span id="cb757-38"><a href="multithreading.html#cb757-38"></a>    thrd_t t<span class="op">[</span>THREAD_COUNT<span class="op">];</span></span>
<span id="cb757-39"><a href="multithreading.html#cb757-39"></a></span>
<span id="cb757-40"><a href="multithreading.html#cb757-40"></a>    <span class="co">// Make a new TSS variable, the free() function is the destructor</span></span>
<span id="cb757-41"><a href="multithreading.html#cb757-41"></a>    tss_create<span class="op">(&amp;</span>str<span class="op">,</span> free<span class="op">);</span></span>
<span id="cb757-42"><a href="multithreading.html#cb757-42"></a></span>
<span id="cb757-43"><a href="multithreading.html#cb757-43"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb757-44"><a href="multithreading.html#cb757-44"></a>        <span class="dt">int</span> <span class="op">*</span>n <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span> <span class="op">*</span>n<span class="op">);</span>  <span class="co">// Holds a thread serial number</span></span>
<span id="cb757-45"><a href="multithreading.html#cb757-45"></a>        <span class="op">*</span>n <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb757-46"><a href="multithreading.html#cb757-46"></a>        thrd_create<span class="op">(</span>t <span class="op">+</span> i<span class="op">,</span> run<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb757-47"><a href="multithreading.html#cb757-47"></a>    <span class="op">}</span></span>
<span id="cb757-48"><a href="multithreading.html#cb757-48"></a></span>
<span id="cb757-49"><a href="multithreading.html#cb757-49"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb757-50"><a href="multithreading.html#cb757-50"></a>        thrd_join<span class="op">(</span>t<span class="op">[</span>i<span class="op">],</span> NULL<span class="op">);</span></span>
<span id="cb757-51"><a href="multithreading.html#cb757-51"></a>    <span class="op">}</span></span>
<span id="cb757-52"><a href="multithreading.html#cb757-52"></a></span>
<span id="cb757-53"><a href="multithreading.html#cb757-53"></a>    <span class="co">// All threads are done, so we&#39;re done with this</span></span>
<span id="cb757-54"><a href="multithreading.html#cb757-54"></a>    tss_delete<span class="op">(</span>str<span class="op">);</span></span>
<span id="cb757-55"><a href="multithreading.html#cb757-55"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>Again, this is kind of a painful way of doing things compared to <code>thread_local</code>, so unless you really need that destructor functionality, I’d use that instead.</p>
<p></p>
<h2 data-number="39.7" id="mutex"><span class="header-section-number">39.7</span> Mutexes</h2>
<p></p>
<p>If you want to only allow a single thread into a critical section of code at a time, you can protect that section with a mutex<a href="function-specifiers-alignment-specifiersoperators.html#fn203" class="footnote-ref" id="fnref203" role="doc-noteref"><sup>203</sup></a>.</p>
<p>For example, if we had a <code>static</code> variable and we wanted to be able to get and set it in two operations without another thread jumping in the middle and corrupting it, we could use a mutex for that.</p>
<p>You can acquire a mutex or release it. If you attempt to acquire the mutex and succeed, you may continue execution. If you attempt and fail (because someone else holds it), you will <em>block</em><a href="function-specifiers-alignment-specifiersoperators.html#fn204" class="footnote-ref" id="fnref204" role="doc-noteref"><sup>204</sup></a> until the mutex is released.</p>
<p>If multiple threads are blocked waiting for a mutex to be released, one of them will be chosen to run (at random, from our perspective), and the others will continue to sleep.</p>
<p>The gameplan is that first we’ll initialize a mutex variable to make it ready to use with <code>mtx_init()</code>.</p>
<p>Then subsequent threads can call <code>mtx_lock()</code> and <code>mtx_unlock()</code> to get and release the mutex.</p>
<p>When we’re completely done with the mutex, we can destroy it with <code>mtx_destroy()</code>, the logical opposite of <code>mtx_init()</code>.</p>
<p></p>
<p>First, let’s look at some code that does <em>not</em> use a mutex, and endeavors to print out a shared (<code>static</code>) serial number and then increment it. Because we’re not using a mutex over the getting of the value (to print it) and the setting (to increment it), threads might get in each other’s way in that critical section.</p>
<div class="sourceCode" id="cb758"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb758-1"><a href="multithreading.html#cb758-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb758-2"><a href="multithreading.html#cb758-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb758-3"><a href="multithreading.html#cb758-3"></a></span>
<span id="cb758-4"><a href="multithreading.html#cb758-4"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb758-5"><a href="multithreading.html#cb758-5"></a><span class="op">{</span></span>
<span id="cb758-6"><a href="multithreading.html#cb758-6"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>arg<span class="op">;</span></span>
<span id="cb758-7"><a href="multithreading.html#cb758-7"></a></span>
<span id="cb758-8"><a href="multithreading.html#cb758-8"></a>    <span class="dt">static</span> <span class="dt">int</span> serial <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>   <span class="co">// Shared static variable!</span></span>
<span id="cb758-9"><a href="multithreading.html#cb758-9"></a></span>
<span id="cb758-10"><a href="multithreading.html#cb758-10"></a>    printf<span class="op">(</span><span class="st">&quot;Thread running! </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> serial<span class="op">);</span></span>
<span id="cb758-11"><a href="multithreading.html#cb758-11"></a></span>
<span id="cb758-12"><a href="multithreading.html#cb758-12"></a>    serial<span class="op">++;</span></span>
<span id="cb758-13"><a href="multithreading.html#cb758-13"></a></span>
<span id="cb758-14"><a href="multithreading.html#cb758-14"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb758-15"><a href="multithreading.html#cb758-15"></a><span class="op">}</span></span>
<span id="cb758-16"><a href="multithreading.html#cb758-16"></a></span>
<span id="cb758-17"><a href="multithreading.html#cb758-17"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">10</span></span>
<span id="cb758-18"><a href="multithreading.html#cb758-18"></a></span>
<span id="cb758-19"><a href="multithreading.html#cb758-19"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb758-20"><a href="multithreading.html#cb758-20"></a><span class="op">{</span></span>
<span id="cb758-21"><a href="multithreading.html#cb758-21"></a>    thrd_t t<span class="op">[</span>THREAD_COUNT<span class="op">];</span></span>
<span id="cb758-22"><a href="multithreading.html#cb758-22"></a></span>
<span id="cb758-23"><a href="multithreading.html#cb758-23"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb758-24"><a href="multithreading.html#cb758-24"></a>        thrd_create<span class="op">(</span>t <span class="op">+</span> i<span class="op">,</span> run<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb758-25"><a href="multithreading.html#cb758-25"></a>    <span class="op">}</span></span>
<span id="cb758-26"><a href="multithreading.html#cb758-26"></a></span>
<span id="cb758-27"><a href="multithreading.html#cb758-27"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb758-28"><a href="multithreading.html#cb758-28"></a>        thrd_join<span class="op">(</span>t<span class="op">[</span>i<span class="op">],</span> NULL<span class="op">);</span></span>
<span id="cb758-29"><a href="multithreading.html#cb758-29"></a>    <span class="op">}</span></span>
<span id="cb758-30"><a href="multithreading.html#cb758-30"></a><span class="op">}</span></span></code></pre></div>
<p>When I run this, I get something that looks like this:</p>
<div class="sourceCode" id="cb759"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb759-1"><a href="multithreading.html#cb759-1" aria-hidden="true" tabindex="-1"></a>Thread running! 0</span>
<span id="cb759-2"><a href="multithreading.html#cb759-2" aria-hidden="true" tabindex="-1"></a>Thread running! 0</span>
<span id="cb759-3"><a href="multithreading.html#cb759-3" aria-hidden="true" tabindex="-1"></a>Thread running! 0</span>
<span id="cb759-4"><a href="multithreading.html#cb759-4" aria-hidden="true" tabindex="-1"></a>Thread running! 3</span>
<span id="cb759-5"><a href="multithreading.html#cb759-5" aria-hidden="true" tabindex="-1"></a>Thread running! 4</span>
<span id="cb759-6"><a href="multithreading.html#cb759-6" aria-hidden="true" tabindex="-1"></a>Thread running! 5</span>
<span id="cb759-7"><a href="multithreading.html#cb759-7" aria-hidden="true" tabindex="-1"></a>Thread running! 6</span>
<span id="cb759-8"><a href="multithreading.html#cb759-8" aria-hidden="true" tabindex="-1"></a>Thread running! 7</span>
<span id="cb759-9"><a href="multithreading.html#cb759-9" aria-hidden="true" tabindex="-1"></a>Thread running! 8</span>
<span id="cb759-10"><a href="multithreading.html#cb759-10" aria-hidden="true" tabindex="-1"></a>Thread running! 9</span></code></pre></div>
<p>Clearly multiple threads are getting in there and running the <code>printf()</code> before anyone gets a change to update the <code>serial</code> variable.</p>
<p></p>
<p>What we want to do is wrap the getting of the variable and setting of it into a single mutex-protected stretch of code.</p>
<p>We’ll add a new variable to represent the mutex of type <code>mtx_t</code> in file scope, initialize it, and then the threads can lock and unlock it in the <code>run()</code> function.</p>
<p> </p>
<div class="sourceCode" id="cb760"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb760-1"><a href="multithreading.html#cb760-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb760-2"><a href="multithreading.html#cb760-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb760-3"><a href="multithreading.html#cb760-3"></a></span>
<span id="cb760-4"><a href="multithreading.html#cb760-4"></a>mtx_t serial_mtx<span class="op">;</span>     <span class="co">// &lt;-- MUTEX VARIABLE</span></span>
<span id="cb760-5"><a href="multithreading.html#cb760-5"></a></span>
<span id="cb760-6"><a href="multithreading.html#cb760-6"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb760-7"><a href="multithreading.html#cb760-7"></a><span class="op">{</span></span>
<span id="cb760-8"><a href="multithreading.html#cb760-8"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>arg<span class="op">;</span></span>
<span id="cb760-9"><a href="multithreading.html#cb760-9"></a></span>
<span id="cb760-10"><a href="multithreading.html#cb760-10"></a>    <span class="dt">static</span> <span class="dt">int</span> serial <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>   <span class="co">// Shared static variable!</span></span>
<span id="cb760-11"><a href="multithreading.html#cb760-11"></a></span>
<span id="cb760-12"><a href="multithreading.html#cb760-12"></a>    <span class="co">// Acquire the mutex--all threads will block on this call until</span></span>
<span id="cb760-13"><a href="multithreading.html#cb760-13"></a>    <span class="co">// they get the lock:</span></span>
<span id="cb760-14"><a href="multithreading.html#cb760-14"></a></span>
<span id="cb760-15"><a href="multithreading.html#cb760-15"></a>    mtx_lock<span class="op">(&amp;</span>serial_mtx<span class="op">);</span>           <span class="co">// &lt;-- ACQUIRE MUTEX</span></span>
<span id="cb760-16"><a href="multithreading.html#cb760-16"></a></span>
<span id="cb760-17"><a href="multithreading.html#cb760-17"></a>    printf<span class="op">(</span><span class="st">&quot;Thread running! </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> serial<span class="op">);</span></span>
<span id="cb760-18"><a href="multithreading.html#cb760-18"></a></span>
<span id="cb760-19"><a href="multithreading.html#cb760-19"></a>    serial<span class="op">++;</span></span>
<span id="cb760-20"><a href="multithreading.html#cb760-20"></a></span>
<span id="cb760-21"><a href="multithreading.html#cb760-21"></a>    <span class="co">// Done getting and setting the data, so free the lock. This will</span></span>
<span id="cb760-22"><a href="multithreading.html#cb760-22"></a>    <span class="co">// unblock threads on the mtx_lock() call:</span></span>
<span id="cb760-23"><a href="multithreading.html#cb760-23"></a></span>
<span id="cb760-24"><a href="multithreading.html#cb760-24"></a>    mtx_unlock<span class="op">(&amp;</span>serial_mtx<span class="op">);</span>         <span class="co">// &lt;-- RELEASE MUTEX</span></span>
<span id="cb760-25"><a href="multithreading.html#cb760-25"></a></span>
<span id="cb760-26"><a href="multithreading.html#cb760-26"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb760-27"><a href="multithreading.html#cb760-27"></a><span class="op">}</span></span>
<span id="cb760-28"><a href="multithreading.html#cb760-28"></a></span>
<span id="cb760-29"><a href="multithreading.html#cb760-29"></a><span class="pp">#define THREAD_COUNT </span><span class="dv">10</span></span>
<span id="cb760-30"><a href="multithreading.html#cb760-30"></a></span>
<span id="cb760-31"><a href="multithreading.html#cb760-31"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb760-32"><a href="multithreading.html#cb760-32"></a><span class="op">{</span></span>
<span id="cb760-33"><a href="multithreading.html#cb760-33"></a>    thrd_t t<span class="op">[</span>THREAD_COUNT<span class="op">];</span></span>
<span id="cb760-34"><a href="multithreading.html#cb760-34"></a></span>
<span id="cb760-35"><a href="multithreading.html#cb760-35"></a>    <span class="co">// Initialize the mutex variable, indicating this is a normal</span></span>
<span id="cb760-36"><a href="multithreading.html#cb760-36"></a>    <span class="co">// no-frills, mutex:</span></span>
<span id="cb760-37"><a href="multithreading.html#cb760-37"></a></span>
<span id="cb760-38"><a href="multithreading.html#cb760-38"></a>    mtx_init<span class="op">(&amp;</span>serial_mtx<span class="op">,</span> mtx_plain<span class="op">);</span>        <span class="co">// &lt;-- CREATE MUTEX</span></span>
<span id="cb760-39"><a href="multithreading.html#cb760-39"></a></span>
<span id="cb760-40"><a href="multithreading.html#cb760-40"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb760-41"><a href="multithreading.html#cb760-41"></a>        thrd_create<span class="op">(</span>t <span class="op">+</span> i<span class="op">,</span> run<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb760-42"><a href="multithreading.html#cb760-42"></a>    <span class="op">}</span></span>
<span id="cb760-43"><a href="multithreading.html#cb760-43"></a></span>
<span id="cb760-44"><a href="multithreading.html#cb760-44"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> THREAD_COUNT<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb760-45"><a href="multithreading.html#cb760-45"></a>        thrd_join<span class="op">(</span>t<span class="op">[</span>i<span class="op">],</span> NULL<span class="op">);</span></span>
<span id="cb760-46"><a href="multithreading.html#cb760-46"></a>    <span class="op">}</span></span>
<span id="cb760-47"><a href="multithreading.html#cb760-47"></a></span>
<span id="cb760-48"><a href="multithreading.html#cb760-48"></a>    <span class="co">// Done with the mutex, destroy it:</span></span>
<span id="cb760-49"><a href="multithreading.html#cb760-49"></a></span>
<span id="cb760-50"><a href="multithreading.html#cb760-50"></a>    mtx_destroy<span class="op">(&amp;</span>serial_mtx<span class="op">);</span>                <span class="co">// &lt;-- DESTROY MUTEX</span></span>
<span id="cb760-51"><a href="multithreading.html#cb760-51"></a><span class="op">}</span></span></code></pre></div>
<p>See how on lines 38 and 50 of <code>main()</code> we initialize and destroy the mutex.</p>
<p> </p>
<p>But each individual thread acquires the mutex on line 15 and releases it on line 24.</p>
<p>In between the <code>mtx_lock()</code> and <code>mtx_unlock()</code> is the <em>critical section</em>, the area of code where we don’t want multiple threads mucking about at the same time.</p>
<p> </p>
<p>And now we get proper output!</p>
<div class="sourceCode" id="cb761"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb761-1"><a href="multithreading.html#cb761-1" aria-hidden="true" tabindex="-1"></a>Thread running! 0</span>
<span id="cb761-2"><a href="multithreading.html#cb761-2" aria-hidden="true" tabindex="-1"></a>Thread running! 1</span>
<span id="cb761-3"><a href="multithreading.html#cb761-3" aria-hidden="true" tabindex="-1"></a>Thread running! 2</span>
<span id="cb761-4"><a href="multithreading.html#cb761-4" aria-hidden="true" tabindex="-1"></a>Thread running! 3</span>
<span id="cb761-5"><a href="multithreading.html#cb761-5" aria-hidden="true" tabindex="-1"></a>Thread running! 4</span>
<span id="cb761-6"><a href="multithreading.html#cb761-6" aria-hidden="true" tabindex="-1"></a>Thread running! 5</span>
<span id="cb761-7"><a href="multithreading.html#cb761-7" aria-hidden="true" tabindex="-1"></a>Thread running! 6</span>
<span id="cb761-8"><a href="multithreading.html#cb761-8" aria-hidden="true" tabindex="-1"></a>Thread running! 7</span>
<span id="cb761-9"><a href="multithreading.html#cb761-9" aria-hidden="true" tabindex="-1"></a>Thread running! 8</span>
<span id="cb761-10"><a href="multithreading.html#cb761-10" aria-hidden="true" tabindex="-1"></a>Thread running! 9</span></code></pre></div>
<p>If you need multiple mutexes, no problem: just have multiple mutex variables.</p>
<p>And always remember the Number One Rule of Multiple Mutexes: <em>Unlock mutexes in the opposite order in which you lock them!</em></p>
<h3 data-number="39.7.1" id="different-mutex-types"><span class="header-section-number">39.7.1</span> Different Mutex Types</h3>
<p></p>
<p>As hinted earlier, we have a few mutex types that you can create with <code>mtx_init()</code>. (Some of these types are the result of a bitwise-OR operation, as noted in the table.)</p>
<p></p>
<p> </p>
<table>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>mtx_plain</code></td>
<td>Regular ol’ mutex</td>
</tr>
<tr class="even">
<td><code>mtx_timed</code></td>
<td>Mutex that supports timeouts</td>
</tr>
<tr class="odd">
<td><code>mtx_plain|mtx_recursive</code></td>
<td>Recursive mutex</td>
</tr>
<tr class="even">
<td><code>mtx_timed|mtx_recursive</code></td>
<td>Recursive mutex that supports timeouts</td>
</tr>
</tbody>
</table>
<p>“Recursive” means that the holder of a lock can call <code>mtx_lock()</code> multiple times on the same lock. (They have to unlock it an equal number of times before anyone else can take the mutex.) This might ease coding from time to time, especially if you call a function that needs to lock the mutex when you already hold the mutex.</p>
<p>And the timeout gives a thread a chance to <em>try</em> to get the lock for a while, but then bail out if it can’t get it in that timeframe.</p>
<p></p>
<p>For a timeout mutex, be sure to create it with <code>mtx_timed</code>:</p>
<div class="sourceCode" id="cb762"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb762-1"><a href="multithreading.html#cb762-1" aria-hidden="true" tabindex="-1"></a>mtx_init<span class="op">(&amp;</span>serial_mtx<span class="op">,</span> mtx_timed<span class="op">);</span></span></code></pre></div>
<p></p>
<p>And then when you wait for it, you have to specify a time in UTC when it will unlock<a href="function-specifiers-alignment-specifiersoperators.html#fn205" class="footnote-ref" id="fnref205" role="doc-noteref"><sup>205</sup></a>.</p>
<p></p>
<p>The function <code>timespec_get()</code> from <code>&lt;time.h&gt;</code> can be of assistance here. It’ll get you the current time in UTC in a <code>struct timespec</code> which is just what we need. In fact, it seems to exist merely for this purpose.</p>
<p>It has two fields: <code>tv_sec</code> has the current time in seconds since epoch, and <code>tv_nsec</code> has the nanoseconds (billionths of a second) as the “fractional” part.</p>
<p>So you can load that up with the current time, and then add to it to get a specific timeout.</p>
<p></p>
<p>Then call <code>mtx_timedlock()</code> instead of <code>mtx_lock()</code>. If it returns the value <code>thrd_timedout</code>, it timed out.</p>
<div class="sourceCode" id="cb763"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb763-1"><a href="multithreading.html#cb763-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> timespec timeout<span class="op">;</span></span>
<span id="cb763-2"><a href="multithreading.html#cb763-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb763-3"><a href="multithreading.html#cb763-3" aria-hidden="true" tabindex="-1"></a>timespec_get<span class="op">(&amp;</span>timeout<span class="op">,</span> TIME_UTC<span class="op">);</span>  <span class="co">// Get current time</span></span>
<span id="cb763-4"><a href="multithreading.html#cb763-4" aria-hidden="true" tabindex="-1"></a>timeout<span class="op">.</span>tv_sec <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span>               <span class="co">// Timeout 1 second after now</span></span>
<span id="cb763-5"><a href="multithreading.html#cb763-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb763-6"><a href="multithreading.html#cb763-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> result <span class="op">=</span> mtx_timedlock<span class="op">(&amp;</span>serial_mtx<span class="op">,</span> <span class="op">&amp;</span>timeout<span class="op">));</span></span>
<span id="cb763-7"><a href="multithreading.html#cb763-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb763-8"><a href="multithreading.html#cb763-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>result <span class="op">==</span> thrd_timedout<span class="op">)</span> <span class="op">{</span></span>
<span id="cb763-9"><a href="multithreading.html#cb763-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Mutex lock timed out!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb763-10"><a href="multithreading.html#cb763-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>Other than that, timed locks are the same as regular locks.</p>
<p> </p>
<h2 data-number="39.8" id="condition-variables"><span class="header-section-number">39.8</span> Condition Variables</h2>
<p></p>
<p>Condition Variables are the last piece of the puzzle we need to make performant multithreaded applications and to compose more complex multithreaded structures.</p>
<p>A condition variable provides a way for threads to go to sleep until some event on another thread occurs.</p>
<p>In other words, we might have a number of threads that are rearing to go, but they have to wait until some event is true before they continue. Basically they’re being told “wait for it!” until they get notified.</p>
<p>And this works hand-in-hand with mutexes since what we’re going to wait on generally depends on the value of some data, and that data generally needs to be protected by a mutex.</p>
<p>It’s important to note that the condition variable itself isn’t the holder of any particular data from our perspective. It’s merely the variable by which C keeps track of the waiting/not-waiting status of a particular thread or group of threads.</p>
<p>Let’s write a contrived program that reads in groups of 5 numbers from the main thread one at a time. Then, when 5 numbers have been entered, the child thread wakes up, sums up those 5 numbers, and prints the result.</p>
<p>The numbers will be stored in a global, shared array, as will the index into the array of the about-to-be-entered number.</p>
<p>Since these are shared values, we at least have to hide them behind a mutex for both the main and child threads. (The main will be writing data to them and the child will be reading data from them.)</p>
<p>But that’s not enough. The child thread needs to block (“sleep”) until 5 numbers have been read into the array. And then the parent thread needs to wake up the child thread so it can do its work.</p>
<p>And when it wakes up, it needs to be holding that mutex. And it will! When a thread waits on a condition variable, it also acquires a mutex when it wakes up.</p>
<p>All this takes place around an additional variable of type <code>cnd_t</code> that is the <em>condition variable</em>. We create this variable with the <code>cnd_init()</code> function and destroy it when we’re done with it with the <code>cnd_destroy()</code> function.</p>
<p>But how’s this all work? Let’s look at the outline of what the child thread will do:</p>
<p> </p>
<ol type="1">
<li>Lock the mutex with <code>mtx_lock()</code></li>
<li>If we haven’t entered all the numbers, wait on the condition variable with <code>cnd_wait()</code></li>
<li>Do the work that needs doing</li>
<li>Unlock the mutex with <code>mtx_unlock()</code></li>
</ol>
<p>Meanwhile the main thread will be doing this:</p>
<ol type="1">
<li>Lock the mutex with <code>mtx_lock()</code></li>
<li>Store the recently-read number into the array</li>
<li>If the array is full, signal the child to wake up with <code>cnd_signal()</code></li>
<li>Unlock the mutex with <code>mtx_unlock()</code></li>
</ol>
<p> </p>
<p>If you didn’t skim that too hard (it’s OK—I’m not offended), you might notice something weird: how can the main thread hold the mutex lock and signal the child, if the child has to hold the mutex lock to wait for the signal? They can’t both hold the lock!</p>
<p>And indeed they don’t! There’s some behind-the-scenes magic with condition variables: when you <code>cnd_wait()</code>, it releases the mutex that you specify and the thread goes to sleep. And when someone signals that thread to wake up, it reacquires the lock as if nothing had happened.</p>
<p>It’s a little different on the <code>cnd_signal()</code> side of things. This doesn’t do anything with the mutex. The signaling thread still must manually release the mutex before the waiting threads can wake up.</p>
<p></p>
<p>One more thing on the <code>cnd_wait()</code>. You’ll probably be calling <code>cnd_wait()</code> if some condition<a href="function-specifiers-alignment-specifiersoperators.html#fn206" class="footnote-ref" id="fnref206" role="doc-noteref"><sup>206</sup></a> is not yet met (e.g. in this case, if not all the numbers have yet been entered). Here’s the deal: this condition should be in a <code>while</code> loop, not an <code>if</code> statement. Why?</p>
<p>It’s because of a mysterious phenomenon called a <em>spurious wakeup</em>. Sometimes, in some implementations, a thread can be woken up out of a <code>cnd_wait()</code> sleep for seemingly <em>no reason</em>. <em>[X-Files music]</em><a href="function-specifiers-alignment-specifiersoperators.html#fn207" class="footnote-ref" id="fnref207" role="doc-noteref"><sup>207</sup></a>. And so we have to check to see that the condition we need is still actually met when we wake up. And if it’s not, back to sleep with us!</p>
<p></p>
<p>So let’s do this thing! Starting with the main thread:</p>
<ul>
<li><p>The main thread will set up the mutex and condition variable, and will launch the child thread.</p></li>
<li><p>Then it will, in an infinite loop, get numbers as input from the console.</p></li>
<li><p>It will also acquire the mutex to store the inputted number into a global array.</p></li>
<li><p>When the array has 5 numbers in it, the main thread will signal the child thread that it’s time to wake up and do its work.</p></li>
<li><p>Then the main thread will unlock the mutex and go back to reading the next number from the console.</p></li>
</ul>
<p>Meanwhile, the child thread has been up to its own shenanigans:</p>
<ul>
<li><p>The child thread grabs the mutex</p></li>
<li><p>While the condition is not met (i.e. while the shared array doesn’t yet have 5 numbers in it), the child thread sleeps by waiting on the condition variable. When it waits, it implicitly unlocks the mutex.</p></li>
<li><p>Once the main thread signals the child thread to wake up, it wakes up to do the work and gets the mutex lock back.</p></li>
<li><p>The child thread sums the numbers and resets the variable that is the index into the array.</p></li>
<li><p>It then releases the mutex and runs again in an infinite loop.</p></li>
</ul>
<p>And here’s the code! Give it some study so you can see where all the above pieces are being handled:</p>
<p> </p>
<div class="sourceCode" id="cb764"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb764-1"><a href="multithreading.html#cb764-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb764-2"><a href="multithreading.html#cb764-2"></a><span class="pp">#include </span><span class="im">&lt;threads.h&gt;</span></span>
<span id="cb764-3"><a href="multithreading.html#cb764-3"></a></span>
<span id="cb764-4"><a href="multithreading.html#cb764-4"></a><span class="pp">#define VALUE_COUNT_MAX </span><span class="dv">5</span></span>
<span id="cb764-5"><a href="multithreading.html#cb764-5"></a></span>
<span id="cb764-6"><a href="multithreading.html#cb764-6"></a><span class="dt">int</span> value<span class="op">[</span>VALUE_COUNT_MAX<span class="op">];</span>  <span class="co">// Shared global</span></span>
<span id="cb764-7"><a href="multithreading.html#cb764-7"></a><span class="dt">int</span> value_count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>   <span class="co">// Shared global, too</span></span>
<span id="cb764-8"><a href="multithreading.html#cb764-8"></a></span>
<span id="cb764-9"><a href="multithreading.html#cb764-9"></a>mtx_t value_mtx<span class="op">;</span>   <span class="co">// Mutex around value</span></span>
<span id="cb764-10"><a href="multithreading.html#cb764-10"></a>cnd_t value_cnd<span class="op">;</span>   <span class="co">// Condition variable on value</span></span>
<span id="cb764-11"><a href="multithreading.html#cb764-11"></a></span>
<span id="cb764-12"><a href="multithreading.html#cb764-12"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb764-13"><a href="multithreading.html#cb764-13"></a><span class="op">{</span></span>
<span id="cb764-14"><a href="multithreading.html#cb764-14"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>arg<span class="op">;</span></span>
<span id="cb764-15"><a href="multithreading.html#cb764-15"></a></span>
<span id="cb764-16"><a href="multithreading.html#cb764-16"></a>    <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb764-17"><a href="multithreading.html#cb764-17"></a>        mtx_lock<span class="op">(&amp;</span>value_mtx<span class="op">);</span>      <span class="co">// &lt;-- GRAB THE MUTEX</span></span>
<span id="cb764-18"><a href="multithreading.html#cb764-18"></a></span>
<span id="cb764-19"><a href="multithreading.html#cb764-19"></a>        <span class="cf">while</span> <span class="op">(</span>value_count <span class="op">&lt;</span> VALUE_COUNT_MAX<span class="op">)</span> <span class="op">{</span></span>
<span id="cb764-20"><a href="multithreading.html#cb764-20"></a>            printf<span class="op">(</span><span class="st">&quot;Thread: is waiting</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb764-21"><a href="multithreading.html#cb764-21"></a>            cnd_wait<span class="op">(&amp;</span>value_cnd<span class="op">,</span> <span class="op">&amp;</span>value_mtx<span class="op">);</span>  <span class="co">// &lt;-- CONDITION WAIT</span></span>
<span id="cb764-22"><a href="multithreading.html#cb764-22"></a>        <span class="op">}</span></span>
<span id="cb764-23"><a href="multithreading.html#cb764-23"></a></span>
<span id="cb764-24"><a href="multithreading.html#cb764-24"></a>        printf<span class="op">(</span><span class="st">&quot;Thread: is awake!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb764-25"><a href="multithreading.html#cb764-25"></a></span>
<span id="cb764-26"><a href="multithreading.html#cb764-26"></a>        <span class="dt">int</span> t <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb764-27"><a href="multithreading.html#cb764-27"></a></span>
<span id="cb764-28"><a href="multithreading.html#cb764-28"></a>        <span class="co">// Add everything up</span></span>
<span id="cb764-29"><a href="multithreading.html#cb764-29"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> VALUE_COUNT_MAX<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb764-30"><a href="multithreading.html#cb764-30"></a>            t <span class="op">+=</span> value<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb764-31"><a href="multithreading.html#cb764-31"></a></span>
<span id="cb764-32"><a href="multithreading.html#cb764-32"></a>        printf<span class="op">(</span><span class="st">&quot;Thread: total is </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> t<span class="op">);</span></span>
<span id="cb764-33"><a href="multithreading.html#cb764-33"></a></span>
<span id="cb764-34"><a href="multithreading.html#cb764-34"></a>        <span class="co">// Reset input index for main thread</span></span>
<span id="cb764-35"><a href="multithreading.html#cb764-35"></a>        value_count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb764-36"><a href="multithreading.html#cb764-36"></a></span>
<span id="cb764-37"><a href="multithreading.html#cb764-37"></a>        mtx_unlock<span class="op">(&amp;</span>value_mtx<span class="op">);</span>   <span class="co">// &lt;-- MUTEX UNLOCK</span></span>
<span id="cb764-38"><a href="multithreading.html#cb764-38"></a>    <span class="op">}</span></span>
<span id="cb764-39"><a href="multithreading.html#cb764-39"></a></span>
<span id="cb764-40"><a href="multithreading.html#cb764-40"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb764-41"><a href="multithreading.html#cb764-41"></a><span class="op">}</span></span>
<span id="cb764-42"><a href="multithreading.html#cb764-42"></a></span>
<span id="cb764-43"><a href="multithreading.html#cb764-43"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb764-44"><a href="multithreading.html#cb764-44"></a><span class="op">{</span></span>
<span id="cb764-45"><a href="multithreading.html#cb764-45"></a>    thrd_t t<span class="op">;</span></span>
<span id="cb764-46"><a href="multithreading.html#cb764-46"></a></span>
<span id="cb764-47"><a href="multithreading.html#cb764-47"></a>    <span class="co">// Spawn a new thread</span></span>
<span id="cb764-48"><a href="multithreading.html#cb764-48"></a></span>
<span id="cb764-49"><a href="multithreading.html#cb764-49"></a>    thrd_create<span class="op">(&amp;</span>t<span class="op">,</span> run<span class="op">,</span> NULL<span class="op">);</span></span>
<span id="cb764-50"><a href="multithreading.html#cb764-50"></a>    thrd_detach<span class="op">(</span>t<span class="op">);</span></span>
<span id="cb764-51"><a href="multithreading.html#cb764-51"></a></span>
<span id="cb764-52"><a href="multithreading.html#cb764-52"></a>    <span class="co">// Set up the mutex and condition variable</span></span>
<span id="cb764-53"><a href="multithreading.html#cb764-53"></a></span>
<span id="cb764-54"><a href="multithreading.html#cb764-54"></a>    mtx_init<span class="op">(&amp;</span>value_mtx<span class="op">,</span> mtx_plain<span class="op">);</span></span>
<span id="cb764-55"><a href="multithreading.html#cb764-55"></a>    cnd_init<span class="op">(&amp;</span>value_cnd<span class="op">);</span></span>
<span id="cb764-56"><a href="multithreading.html#cb764-56"></a></span>
<span id="cb764-57"><a href="multithreading.html#cb764-57"></a>    <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb764-58"><a href="multithreading.html#cb764-58"></a>        <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb764-59"><a href="multithreading.html#cb764-59"></a></span>
<span id="cb764-60"><a href="multithreading.html#cb764-60"></a>        scanf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">&amp;</span>n<span class="op">);</span></span>
<span id="cb764-61"><a href="multithreading.html#cb764-61"></a></span>
<span id="cb764-62"><a href="multithreading.html#cb764-62"></a>        mtx_lock<span class="op">(&amp;</span>value_mtx<span class="op">);</span>    <span class="co">// &lt;-- LOCK MUTEX</span></span>
<span id="cb764-63"><a href="multithreading.html#cb764-63"></a></span>
<span id="cb764-64"><a href="multithreading.html#cb764-64"></a>        value<span class="op">[</span>value_count<span class="op">++]</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb764-65"><a href="multithreading.html#cb764-65"></a></span>
<span id="cb764-66"><a href="multithreading.html#cb764-66"></a>        <span class="cf">if</span> <span class="op">(</span>value_count <span class="op">==</span> VALUE_COUNT_MAX<span class="op">)</span> <span class="op">{</span></span>
<span id="cb764-67"><a href="multithreading.html#cb764-67"></a>            printf<span class="op">(</span><span class="st">&quot;Main: signaling thread</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb764-68"><a href="multithreading.html#cb764-68"></a>            cnd_signal<span class="op">(&amp;</span>value_cnd<span class="op">);</span>  <span class="co">// &lt;-- SIGNAL CONDITION</span></span>
<span id="cb764-69"><a href="multithreading.html#cb764-69"></a>        <span class="op">}</span></span>
<span id="cb764-70"><a href="multithreading.html#cb764-70"></a></span>
<span id="cb764-71"><a href="multithreading.html#cb764-71"></a>        mtx_unlock<span class="op">(&amp;</span>value_mtx<span class="op">);</span>  <span class="co">// &lt;-- UNLOCK MUTEX</span></span>
<span id="cb764-72"><a href="multithreading.html#cb764-72"></a>    <span class="op">}</span></span>
<span id="cb764-73"><a href="multithreading.html#cb764-73"></a></span>
<span id="cb764-74"><a href="multithreading.html#cb764-74"></a>    <span class="co">// Clean up (I know that&#39;s an infinite loop above here, but I</span></span>
<span id="cb764-75"><a href="multithreading.html#cb764-75"></a>    <span class="co">// want to at least pretend to be proper):</span></span>
<span id="cb764-76"><a href="multithreading.html#cb764-76"></a></span>
<span id="cb764-77"><a href="multithreading.html#cb764-77"></a>    mtx_destroy<span class="op">(&amp;</span>value_mtx<span class="op">);</span></span>
<span id="cb764-78"><a href="multithreading.html#cb764-78"></a>    cnd_destroy<span class="op">(&amp;</span>value_cnd<span class="op">);</span></span>
<span id="cb764-79"><a href="multithreading.html#cb764-79"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<p>And here’s some sample output (individual numbers on lines are my input):</p>
<div class="sourceCode" id="cb765"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb765-1"><a href="multithreading.html#cb765-1" aria-hidden="true" tabindex="-1"></a>Thread: is waiting</span>
<span id="cb765-2"><a href="multithreading.html#cb765-2" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb765-3"><a href="multithreading.html#cb765-3" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb765-4"><a href="multithreading.html#cb765-4" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb765-5"><a href="multithreading.html#cb765-5" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb765-6"><a href="multithreading.html#cb765-6" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb765-7"><a href="multithreading.html#cb765-7" aria-hidden="true" tabindex="-1"></a>Main: signaling thread</span>
<span id="cb765-8"><a href="multithreading.html#cb765-8" aria-hidden="true" tabindex="-1"></a>Thread: is awake!</span>
<span id="cb765-9"><a href="multithreading.html#cb765-9" aria-hidden="true" tabindex="-1"></a>Thread: total is 5</span>
<span id="cb765-10"><a href="multithreading.html#cb765-10" aria-hidden="true" tabindex="-1"></a>Thread: is waiting</span>
<span id="cb765-11"><a href="multithreading.html#cb765-11" aria-hidden="true" tabindex="-1"></a>2</span>
<span id="cb765-12"><a href="multithreading.html#cb765-12" aria-hidden="true" tabindex="-1"></a>8</span>
<span id="cb765-13"><a href="multithreading.html#cb765-13" aria-hidden="true" tabindex="-1"></a>5</span>
<span id="cb765-14"><a href="multithreading.html#cb765-14" aria-hidden="true" tabindex="-1"></a>9</span>
<span id="cb765-15"><a href="multithreading.html#cb765-15" aria-hidden="true" tabindex="-1"></a>0</span>
<span id="cb765-16"><a href="multithreading.html#cb765-16" aria-hidden="true" tabindex="-1"></a>Main: signaling thread</span>
<span id="cb765-17"><a href="multithreading.html#cb765-17" aria-hidden="true" tabindex="-1"></a>Thread: is awake!</span>
<span id="cb765-18"><a href="multithreading.html#cb765-18" aria-hidden="true" tabindex="-1"></a>Thread: total is 24</span>
<span id="cb765-19"><a href="multithreading.html#cb765-19" aria-hidden="true" tabindex="-1"></a>Thread: is waiting</span></code></pre></div>
<p>It’s a common use of condition variables in producer-consumer situations like this. If we didn’t have a way to put the child thread to sleep while it waited for some condition to be met, it would be force to poll which is a big waste of CPU.</p>
<h3 data-number="39.8.1" id="timed-condition-wait"><span class="header-section-number">39.8.1</span> Timed Condition Wait</h3>
<p></p>
<p>There’s a variant of <code>cnd_wait()</code> that allows you to specify a timeout so you can stop waiting.</p>
<p>Since the child thread must relock the mutex, this doesn’t necessarily mean that you’ll be popping back to life the instant the timeout occurs; you still must wait for any other threads to release the mutex.</p>
<p>But it does mean that you won’t be waiting until the <code>cnd_signal()</code> happens.</p>
<p>To make this work, call <code>cnd_timedwait()</code> instead of <code>cnd_wait()</code>. If it returns the value <code>thrd_timedout</code>, it timed out.</p>
<p>The timestamp is an absolute time in UTC, not a time-from-now. Thankfully the <code>timespec_get()</code> function in <code>&lt;time.h&gt;</code> seems custom-made for exactly this case.</p>
<p> </p>
<div class="sourceCode" id="cb766"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb766-1"><a href="multithreading.html#cb766-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> timespec timeout<span class="op">;</span></span>
<span id="cb766-2"><a href="multithreading.html#cb766-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb766-3"><a href="multithreading.html#cb766-3" aria-hidden="true" tabindex="-1"></a>timespec_get<span class="op">(&amp;</span>timeout<span class="op">,</span> TIME_UTC<span class="op">);</span>  <span class="co">// Get current time</span></span>
<span id="cb766-4"><a href="multithreading.html#cb766-4" aria-hidden="true" tabindex="-1"></a>timeout<span class="op">.</span>tv_sec <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span>               <span class="co">// Timeout 1 second after now</span></span>
<span id="cb766-5"><a href="multithreading.html#cb766-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb766-6"><a href="multithreading.html#cb766-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> result <span class="op">=</span> cnd_timedwait<span class="op">(&amp;</span>condition<span class="op">,</span> <span class="op">&amp;</span>mutex<span class="op">,</span> <span class="op">&amp;</span>timeout<span class="op">));</span></span>
<span id="cb766-7"><a href="multithreading.html#cb766-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb766-8"><a href="multithreading.html#cb766-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>result <span class="op">==</span> thrd_timedout<span class="op">)</span> <span class="op">{</span></span>
<span id="cb766-9"><a href="multithreading.html#cb766-9" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Condition variable timed out!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb766-10"><a href="multithreading.html#cb766-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p> </p>
<h3 data-number="39.8.2" id="broadcast-wake-up-all-waiting-threads"><span class="header-section-number">39.8.2</span> Broadcast: Wake Up All Waiting Threads</h3>
<p></p>
<p> <code>cnd_signal()</code> only wakes up one thread to continue working. Depending on how you have your logic done, it might make sense to wake up more than one thread to continue once the condition is met.</p>
<p>Of course only one of them can grab the mutex, but if you have a situation where:</p>
<ul>
<li><p>The newly-awoken thread is responsible for waking up the next one, and—</p></li>
<li><p>There’s a chance the spurious-wakeup loop condition will prevent it from doing so, then—</p></li>
</ul>
<p>you’ll want to broadcast the wake up so that you’re sure to get at least one of the threads out of that loop to launch the next one.</p>
<p>How, you ask?</p>
<p></p>
<p>Simply use <code>cnd_broadcast()</code> instead of <code>cnd_signal()</code>. Exact same usage, except <code>cnd_broadcast()</code> wakes up <strong>all</strong> the sleeping threads that were waiting on that condition variable.</p>
<p> </p>
<h2 data-number="39.9" id="running-a-function-one-time"><span class="header-section-number">39.9</span> Running a Function One Time</h2>
<p></p>
<p>Let’s say you have a function that <em>could</em> be run by many threads, but you don’t know when, and it’s not work trying to write all that logic.</p>
<p>There’s a way around it: use <code>call_once()</code>. Tons of threads could try to run the function, but only the first one counts<a href="function-specifiers-alignment-specifiersoperators.html#fn208" class="footnote-ref" id="fnref208" role="doc-noteref"><sup>208</sup></a></p>
<p>To work with this, you need a special flag variable you declare to keep track of whether or not the thing’s been run. And you need a function to run, which takes no parameters and returns no value.</p>
<p> </p>
<div class="sourceCode" id="cb767"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb767-1"><a href="multithreading.html#cb767-1" aria-hidden="true" tabindex="-1"></a>once_flag of <span class="op">=</span> ONCE_FLAG_INIT<span class="op">;</span>  <span class="co">// Initialize it like this</span></span>
<span id="cb767-2"><a href="multithreading.html#cb767-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb767-3"><a href="multithreading.html#cb767-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> run_once_function<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb767-4"><a href="multithreading.html#cb767-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb767-5"><a href="multithreading.html#cb767-5" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;I&#39;ll only run once!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb767-6"><a href="multithreading.html#cb767-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb767-7"><a href="multithreading.html#cb767-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb767-8"><a href="multithreading.html#cb767-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> run<span class="op">(</span><span class="dt">void</span> <span class="op">*</span>arg<span class="op">)</span></span>
<span id="cb767-9"><a href="multithreading.html#cb767-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb767-10"><a href="multithreading.html#cb767-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span><span class="dt">void</span><span class="op">)</span>arg<span class="op">;</span></span>
<span id="cb767-11"><a href="multithreading.html#cb767-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb767-12"><a href="multithreading.html#cb767-12" aria-hidden="true" tabindex="-1"></a>    call_once<span class="op">(&amp;</span>of<span class="op">,</span> run_once_function<span class="op">);</span></span>
<span id="cb767-13"><a href="multithreading.html#cb767-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb767-14"><a href="multithreading.html#cb767-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span></code></pre></div>
<p> </p>
<p>In this example, no matter how many threads get to the <code>run()</code> function, the <code>run_once_function()</code> will only be called a single time.</p>
<p> </p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<hr><div style="text-align:center"><span><a href="date-and-time-functionality.html" rel="prev">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="chapter-atomics.html" rel="next">Next</a></span></div></body>
</html>
