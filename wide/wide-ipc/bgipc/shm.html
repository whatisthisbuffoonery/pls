<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Beej's Guide to Interprocess Communication</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!-- BG custom styling -->
  <style type="text/css">
  /* Fix for line numbers not visible */
  pre.numberSource code > span {
      left: -1em;
  }
  pre.numberSource {
      margin-left: initial;
  }

  /* Put some space after the section numbers */
  span.toc-section-number::after {
      content: "\a0\a0\a0";  /* non-breaking whitespace */
  }

  /* Hide underlines on code number links */
  pre > code.sourceCode > span > a:first-child::before {
      text-decoration: none;
  }

  /* Color the source blocks */
  div.sourceCode {
      background-color: #f0f0f0;
  }

  /* Fix iOS big text rendering issue */
  pre > code.sourceCode > span {
      display: initial;
  }


  /* Color the inline code */
  code:not(.sourceCode) {
      background: #f0f0f0;
      padding-left: 0.2em;
      padding-right: 0.2em;
      border-radius: 0.2em;
  }

  pre.sourceCode {
      border: 1px solid #ccc;
      padding: 0.5em;
      border-radius: 0.2em;
  }

  /* Keep code tags from wrapping in tables */
  tbody code {
      white-space: nowrap;
  }

  /* Prevent hyphenation and hyphen breaks in code*/
  code {
      word-break: keep-all;
  }

  td {
      vertical-align: top;
  }

  body {
      font-size: 12pt;
      max-width: 43em;
      font-family: sans-serif;
  }

  html {
      background: #f9f9f9;
  }

  figure > embed {
      max-width: 100%;
  }

  figure {
      text-align: center;
      margin-top: 2em;
      margin-bottom: 2em;
  }

  figcaption {
      font-size: 0.9em;
      font-style: italic;
      margin-top: 0.6em;
  }

  body {
      counter-reset: figure-counter-major;
      counter-reset: figure-counter-minor;
  }

  figure {
      counter-increment: figure-counter-minor;
  }

  figcaption::before {
      content: "Figure " counter(figure-counter-major) "." counter(figure-counter-minor) ": ";
  }

  blockquote {
      border-left: 2px solid #bbb;
      color: #444;
  }

  /* Contents */

  nav[role="doc-toc"] > ul > li {
    font-weight: bold;
    margin-top: 1.2em;
  }

  nav[role="doc-toc"] > ul > li:first {
    font-weight: bold;
    margin-top: initial;
  }

  nav[role="doc-toc"] > ul > li > ul {
    font-weight: normal;
    margin-top: 0.3em;
  }

  /*
  In multipage, we need to reset the figure counter to the chapter
  number. Luckily, this is in the <h1 data-number> attribute. Unluckily,
  there is no way to get this in a general way.

  This doesn't work:

    h1[data-number] {
      counter-set: figure-counter-major attr(data-number);
    }

  Nor this:

    h1[data-number] {
      --figure-counter-major-value: attr(data-number);
      counter-set: figure-counter-major var(--figure-counter-major-value);
    }

  So, dumbly, we have a bunch of rules for all these sections, up to the
  maximum possible section.

  Here's a program to generate them:

    for (let i = 1; i < 100; i++)
        console.log(`h1[data-number="${i}"]{counter-set:figure-counter-major ${i};counter-reset:figure-counter-minor;}`);

  Note to self: never write a book with more than 99 frickin' chapters.
  */

  h1[data-number="1"]{counter-set:figure-counter-major 1;counter-reset:figure-counter-minor;}
  h1[data-number="2"]{counter-set:figure-counter-major 2;counter-reset:figure-counter-minor;}
  h1[data-number="3"]{counter-set:figure-counter-major 3;counter-reset:figure-counter-minor;}
  h1[data-number="4"]{counter-set:figure-counter-major 4;counter-reset:figure-counter-minor;}
  h1[data-number="5"]{counter-set:figure-counter-major 5;counter-reset:figure-counter-minor;}
  h1[data-number="6"]{counter-set:figure-counter-major 6;counter-reset:figure-counter-minor;}
  h1[data-number="7"]{counter-set:figure-counter-major 7;counter-reset:figure-counter-minor;}
  h1[data-number="8"]{counter-set:figure-counter-major 8;counter-reset:figure-counter-minor;}
  h1[data-number="9"]{counter-set:figure-counter-major 9;counter-reset:figure-counter-minor;}
  h1[data-number="10"]{counter-set:figure-counter-major 10;counter-reset:figure-counter-minor;}
  h1[data-number="11"]{counter-set:figure-counter-major 11;counter-reset:figure-counter-minor;}
  h1[data-number="12"]{counter-set:figure-counter-major 12;counter-reset:figure-counter-minor;}
  h1[data-number="13"]{counter-set:figure-counter-major 13;counter-reset:figure-counter-minor;}
  h1[data-number="14"]{counter-set:figure-counter-major 14;counter-reset:figure-counter-minor;}
  h1[data-number="15"]{counter-set:figure-counter-major 15;counter-reset:figure-counter-minor;}
  h1[data-number="16"]{counter-set:figure-counter-major 16;counter-reset:figure-counter-minor;}
  h1[data-number="17"]{counter-set:figure-counter-major 17;counter-reset:figure-counter-minor;}
  h1[data-number="18"]{counter-set:figure-counter-major 18;counter-reset:figure-counter-minor;}
  h1[data-number="19"]{counter-set:figure-counter-major 19;counter-reset:figure-counter-minor;}
  h1[data-number="20"]{counter-set:figure-counter-major 20;counter-reset:figure-counter-minor;}
  h1[data-number="21"]{counter-set:figure-counter-major 21;counter-reset:figure-counter-minor;}
  h1[data-number="22"]{counter-set:figure-counter-major 22;counter-reset:figure-counter-minor;}
  h1[data-number="23"]{counter-set:figure-counter-major 23;counter-reset:figure-counter-minor;}
  h1[data-number="24"]{counter-set:figure-counter-major 24;counter-reset:figure-counter-minor;}
  h1[data-number="25"]{counter-set:figure-counter-major 25;counter-reset:figure-counter-minor;}
  h1[data-number="26"]{counter-set:figure-counter-major 26;counter-reset:figure-counter-minor;}
  h1[data-number="27"]{counter-set:figure-counter-major 27;counter-reset:figure-counter-minor;}
  h1[data-number="28"]{counter-set:figure-counter-major 28;counter-reset:figure-counter-minor;}
  h1[data-number="29"]{counter-set:figure-counter-major 29;counter-reset:figure-counter-minor;}
  h1[data-number="30"]{counter-set:figure-counter-major 30;counter-reset:figure-counter-minor;}
  h1[data-number="31"]{counter-set:figure-counter-major 31;counter-reset:figure-counter-minor;}
  h1[data-number="32"]{counter-set:figure-counter-major 32;counter-reset:figure-counter-minor;}
  h1[data-number="33"]{counter-set:figure-counter-major 33;counter-reset:figure-counter-minor;}
  h1[data-number="34"]{counter-set:figure-counter-major 34;counter-reset:figure-counter-minor;}
  h1[data-number="35"]{counter-set:figure-counter-major 35;counter-reset:figure-counter-minor;}
  h1[data-number="36"]{counter-set:figure-counter-major 36;counter-reset:figure-counter-minor;}
  h1[data-number="37"]{counter-set:figure-counter-major 37;counter-reset:figure-counter-minor;}
  h1[data-number="38"]{counter-set:figure-counter-major 38;counter-reset:figure-counter-minor;}
  h1[data-number="39"]{counter-set:figure-counter-major 39;counter-reset:figure-counter-minor;}
  h1[data-number="40"]{counter-set:figure-counter-major 40;counter-reset:figure-counter-minor;}
  h1[data-number="41"]{counter-set:figure-counter-major 41;counter-reset:figure-counter-minor;}
  h1[data-number="42"]{counter-set:figure-counter-major 42;counter-reset:figure-counter-minor;}
  h1[data-number="43"]{counter-set:figure-counter-major 43;counter-reset:figure-counter-minor;}
  h1[data-number="44"]{counter-set:figure-counter-major 44;counter-reset:figure-counter-minor;}
  h1[data-number="45"]{counter-set:figure-counter-major 45;counter-reset:figure-counter-minor;}
  h1[data-number="46"]{counter-set:figure-counter-major 46;counter-reset:figure-counter-minor;}
  h1[data-number="47"]{counter-set:figure-counter-major 47;counter-reset:figure-counter-minor;}
  h1[data-number="48"]{counter-set:figure-counter-major 48;counter-reset:figure-counter-minor;}
  h1[data-number="49"]{counter-set:figure-counter-major 49;counter-reset:figure-counter-minor;}
  h1[data-number="50"]{counter-set:figure-counter-major 50;counter-reset:figure-counter-minor;}
  h1[data-number="51"]{counter-set:figure-counter-major 51;counter-reset:figure-counter-minor;}
  h1[data-number="52"]{counter-set:figure-counter-major 52;counter-reset:figure-counter-minor;}
  h1[data-number="53"]{counter-set:figure-counter-major 53;counter-reset:figure-counter-minor;}
  h1[data-number="54"]{counter-set:figure-counter-major 54;counter-reset:figure-counter-minor;}
  h1[data-number="55"]{counter-set:figure-counter-major 55;counter-reset:figure-counter-minor;}
  h1[data-number="56"]{counter-set:figure-counter-major 56;counter-reset:figure-counter-minor;}
  h1[data-number="57"]{counter-set:figure-counter-major 57;counter-reset:figure-counter-minor;}
  h1[data-number="58"]{counter-set:figure-counter-major 58;counter-reset:figure-counter-minor;}
  h1[data-number="59"]{counter-set:figure-counter-major 59;counter-reset:figure-counter-minor;}
  h1[data-number="60"]{counter-set:figure-counter-major 60;counter-reset:figure-counter-minor;}
  h1[data-number="61"]{counter-set:figure-counter-major 61;counter-reset:figure-counter-minor;}
  h1[data-number="62"]{counter-set:figure-counter-major 62;counter-reset:figure-counter-minor;}
  h1[data-number="63"]{counter-set:figure-counter-major 63;counter-reset:figure-counter-minor;}
  h1[data-number="64"]{counter-set:figure-counter-major 64;counter-reset:figure-counter-minor;}
  h1[data-number="65"]{counter-set:figure-counter-major 65;counter-reset:figure-counter-minor;}
  h1[data-number="66"]{counter-set:figure-counter-major 66;counter-reset:figure-counter-minor;}
  h1[data-number="67"]{counter-set:figure-counter-major 67;counter-reset:figure-counter-minor;}
  h1[data-number="68"]{counter-set:figure-counter-major 68;counter-reset:figure-counter-minor;}
  h1[data-number="69"]{counter-set:figure-counter-major 69;counter-reset:figure-counter-minor;}
  h1[data-number="70"]{counter-set:figure-counter-major 70;counter-reset:figure-counter-minor;}
  h1[data-number="71"]{counter-set:figure-counter-major 71;counter-reset:figure-counter-minor;}
  h1[data-number="72"]{counter-set:figure-counter-major 72;counter-reset:figure-counter-minor;}
  h1[data-number="73"]{counter-set:figure-counter-major 73;counter-reset:figure-counter-minor;}
  h1[data-number="74"]{counter-set:figure-counter-major 74;counter-reset:figure-counter-minor;}
  h1[data-number="75"]{counter-set:figure-counter-major 75;counter-reset:figure-counter-minor;}
  h1[data-number="76"]{counter-set:figure-counter-major 76;counter-reset:figure-counter-minor;}
  h1[data-number="77"]{counter-set:figure-counter-major 77;counter-reset:figure-counter-minor;}
  h1[data-number="78"]{counter-set:figure-counter-major 78;counter-reset:figure-counter-minor;}
  h1[data-number="79"]{counter-set:figure-counter-major 79;counter-reset:figure-counter-minor;}
  h1[data-number="80"]{counter-set:figure-counter-major 80;counter-reset:figure-counter-minor;}
  h1[data-number="81"]{counter-set:figure-counter-major 81;counter-reset:figure-counter-minor;}
  h1[data-number="82"]{counter-set:figure-counter-major 82;counter-reset:figure-counter-minor;}
  h1[data-number="83"]{counter-set:figure-counter-major 83;counter-reset:figure-counter-minor;}
  h1[data-number="84"]{counter-set:figure-counter-major 84;counter-reset:figure-counter-minor;}
  h1[data-number="85"]{counter-set:figure-counter-major 85;counter-reset:figure-counter-minor;}
  h1[data-number="86"]{counter-set:figure-counter-major 86;counter-reset:figure-counter-minor;}
  h1[data-number="87"]{counter-set:figure-counter-major 87;counter-reset:figure-counter-minor;}
  h1[data-number="88"]{counter-set:figure-counter-major 88;counter-reset:figure-counter-minor;}
  h1[data-number="89"]{counter-set:figure-counter-major 89;counter-reset:figure-counter-minor;}
  h1[data-number="90"]{counter-set:figure-counter-major 90;counter-reset:figure-counter-minor;}
  h1[data-number="91"]{counter-set:figure-counter-major 91;counter-reset:figure-counter-minor;}
  h1[data-number="92"]{counter-set:figure-counter-major 92;counter-reset:figure-counter-minor;}
  h1[data-number="93"]{counter-set:figure-counter-major 93;counter-reset:figure-counter-minor;}
  h1[data-number="94"]{counter-set:figure-counter-major 94;counter-reset:figure-counter-minor;}
  h1[data-number="95"]{counter-set:figure-counter-major 95;counter-reset:figure-counter-minor;}
  h1[data-number="96"]{counter-set:figure-counter-major 96;counter-reset:figure-counter-minor;}
  h1[data-number="97"]{counter-set:figure-counter-major 97;counter-reset:figure-counter-minor;}
  h1[data-number="98"]{counter-set:figure-counter-major 98;counter-reset:figure-counter-minor;}
  h1[data-number="99"]{counter-set:figure-counter-major 99;counter-reset:figure-counter-minor;}


  </style>
  <!-- BG custom styling for the wide body variant -->
  <!-- Gets appended after bg-css.html -->

  <style type="text/css">
  body {
      max-width: inherit;
  }
  </style>
</head>
<body>
<div style="text-align:center"><span><a href="semaphores.html" rel="prev">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="mmap.html" rel="next">Next</a></span></div><hr>
<h1 data-number="9" id="shm"><span class="header-section-number">9</span> Shared Memory Segments</h1>
<p>The cool thing about shared memory segments is that they are what they sound like: a segment of memory that is shared between processes. I mean, think of the potential of this! You could allocate a block of player information for a multi-player game and have each process access it at will! Fun, fun, fun. (Of course, memory-mapped files accomplish the same thing and have the added advantage of persistence, albeit with the same caveats that apply to shared memory.)</p>
<p>There are, as usual, more gotchas to watch out for, but it’s all pretty easy in the long run. See, you just connect to the shared memory segment, and get a pointer to the memory. You can read and write to this pointer and all changes you make will be visible to everyone else connected to the segment. There is nothing simpler. Well, there is, actually, but I was just trying to make you more comfortable.</p>
<h2 data-number="9.1" id="creating-the-segment-and-connecting"><span class="header-section-number">9.1</span> Creating the segment and connecting</h2>
<p>Similarly to other forms of System V IPC, a shared memory segment is created and connected to via the <code>shmget()</code> call:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="shm.html#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shmget<span class="op">(</span>key_t key<span class="op">,</span> <span class="dt">size_t</span> size<span class="op">,</span> <span class="dt">int</span> shmflg<span class="op">);</span></span></code></pre></div>
<p>Upon successful completion, <code>shmget()</code> returns an identifier for the shared memory segment. The <code>key</code> argument should be created the same was as shown in the <a href="mq.html#mqftok">Message Queues</a> document, using <code>ftok()</code>. The next argument, <code>size</code>, is the size in bytes of the shared memory segment. Finally, the <code>shmflg</code> should be set to the permissions of the segment bitwise-OR’d with <code>IPC_CREAT</code> if you want to create the segment, but can be <code>0</code> otherwise. (It doesn’t hurt to specify <code>IPC_CREAT</code> every time—it will simply connect you if the segment already exists.)</p>
<p>Here’s an example call that creates a 1K segment with <code>644</code> permissions (<code>rw-r--r--</code>):</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="shm.html#cb51-1" aria-hidden="true" tabindex="-1"></a>key_t key<span class="op">;</span></span>
<span id="cb51-2"><a href="shm.html#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shmid<span class="op">;</span></span>
<span id="cb51-3"><a href="shm.html#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="shm.html#cb51-4" aria-hidden="true" tabindex="-1"></a>key <span class="op">=</span> ftok<span class="op">(</span><span class="st">&quot;/home/beej/somefile3&quot;</span><span class="op">,</span> <span class="ch">&#39;R&#39;</span><span class="op">);</span></span>
<span id="cb51-5"><a href="shm.html#cb51-5" aria-hidden="true" tabindex="-1"></a>shmid <span class="op">=</span> shmget<span class="op">(</span>key<span class="op">,</span> <span class="dv">1024</span><span class="op">,</span> <span class="bn">0644</span> <span class="op">|</span> IPC_CREAT<span class="op">);</span></span></code></pre></div>
<p>(It may not be possible to actually create a 1K segment, as the operating system is allowed to increase the size to fit any internal constraints it may have. For example, on a system with 4K virtual pages, it’s likely the size will be increased to 4K. Of course, your program won’t know or care; this is just an implementation detail.)</p>
<p>But how do you get a pointer to that data from the <code>shmid</code> handle? The answer is in the call <code>shmat()</code>, in the following section.</p>
<h2 data-number="9.2" id="attach-megetting-a-pointer-to-the-segment"><span class="header-section-number">9.2</span> Attach me—getting a pointer to the segment</h2>
<p>Before you can use a shared memory segment, you have to attach yourself to it using the <code>shmat()</code> call:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb52-1"><a href="shm.html#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>shmat<span class="op">(</span><span class="dt">int</span> `shmid`<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>`shmaddr`<span class="op">,</span> <span class="dt">int</span> `shmflg`<span class="op">);</span></span></code></pre></div>
<p>What does it all mean? Well, <code>shmid</code> is the shared memory ID you got from the call to <code>shmget()</code>. Next is <code>shmaddr</code>, which you can use to tell <code>shmat()</code> which specific address to use but you should just set it to <code>0</code> and let the OS choose the address for you. Finally, the <code>shmflg</code> can be set to <code>SHM_RDONLY</code> if you only want to read from it, <code>0</code> otherwise. (Check the man pages for other useful flags that can be included.)</p>
<p>Here’s a more complete example of how to get a pointer to a shared memory segment:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="shm.html#cb53-1" aria-hidden="true" tabindex="-1"></a>key_t key<span class="op">;</span></span>
<span id="cb53-2"><a href="shm.html#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> shmid<span class="op">;</span></span>
<span id="cb53-3"><a href="shm.html#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>data<span class="op">;</span></span>
<span id="cb53-4"><a href="shm.html#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="shm.html#cb53-5" aria-hidden="true" tabindex="-1"></a>key <span class="op">=</span> ftok<span class="op">(</span><span class="st">&quot;/home/beej/somefile3&quot;</span><span class="op">,</span> <span class="ch">&#39;R&#39;</span><span class="op">);</span></span>
<span id="cb53-6"><a href="shm.html#cb53-6" aria-hidden="true" tabindex="-1"></a>shmid <span class="op">=</span> shmget<span class="op">(</span>key<span class="op">,</span> <span class="dv">1024</span><span class="op">,</span> <span class="bn">0644</span> <span class="op">|</span> IPC_CREAT<span class="op">);</span></span>
<span id="cb53-7"><a href="shm.html#cb53-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> shmat<span class="op">(</span>shmid<span class="op">,</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div>
<p>And <em>bammo</em>! You have the pointer to the shared memory segment! Notice that <code>shmat()</code> returns a <code>void</code> pointer, and we’re treating it, in this case, as a <code>char</code> pointer. You can treat it as anything you like, depending on what kind of data you have in there. Pointers to arrays of structures are just as acceptable as anything else.</p>
<p>Also, it’s interesting to note that <code>shmat()</code> returns <code>-1</code> on failure (as does <code>mmap()</code>). But how do you get <code>-1</code> in a <code>void</code> pointer? Just do a cast during the comparison to check for errors:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="shm.html#cb54-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> shmat<span class="op">(</span>shmid<span class="op">,</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb54-2"><a href="shm.html#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>data <span class="op">==</span> MAP_FAILED<span class="op">)</span></span>
<span id="cb54-3"><a href="shm.html#cb54-3" aria-hidden="true" tabindex="-1"></a>    perror<span class="op">(</span><span class="st">&quot;shmat&quot;</span><span class="op">);</span></span></code></pre></div>
<p>(It’s important to note that the integer is being cast to a pointer, and not the pointer return value being cast to an integer. It’s a subtle difference, but the latter is not always portable between architectures. Also note that the cast is to <code>void*</code> and not <code>char*</code>, as you might expect. Since the language guarantees that implicit casts from <code>void*</code> to any other kind of pointer are always safe and reliable, it’s better to use <code>void*</code> and let the compiler to the work.)</p>
<p>All you have to do now is change the data it points to normal pointer-style. There are some samples in the next section.</p>
<h2 data-number="9.3" id="reading-and-writing"><span class="header-section-number">9.3</span> Reading and Writing</h2>
<p>Lets say you have the <code>data</code> pointer from the above example. It is a <code>char</code> pointer, so we’ll be reading and writing chars from it. Furthermore, for the sake of simplicity, lets say the 1K shared memory segment contains a null-terminated string.</p>
<p>It couldn’t be easier. Since it’s just a string in there, we can print it like this:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="shm.html#cb55-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;shared contents: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> data<span class="op">);</span></span></code></pre></div>
<p>And we could store something in it as easily as this:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="shm.html#cb56-1" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;Enter a string: &quot;</span><span class="op">);</span></span>
<span id="cb56-2"><a href="shm.html#cb56-2" aria-hidden="true" tabindex="-1"></a>fgets<span class="op">(</span>data<span class="op">,</span> <span class="dv">1024</span><span class="op">,</span> stdin<span class="op">);</span></span></code></pre></div>
<p>Of course, like I said earlier, you can have other data in there besides just <code>char</code>s. I’m just using them as an example. I’ll just make the assumption that you’re familiar enough with pointers in C that you’ll be able to deal with whatever kind of data you stick in there.</p>
<h2 data-number="9.4" id="detaching-from-and-deleting-segments"><span class="header-section-number">9.4</span> Detaching from and deleting segments</h2>
<p>When you’re done with the shared memory segment, your program should detach itself from it using the <code>shmdt()</code> call (if you don’t, this will happen automatically when the process terminates):</p>
<p><code>{.c{ int shmdt(void *`shmaddr`);</code></p>
<p>The only argument, <code>shmaddr</code>, is the address you got from <code>shmat()</code>. The function returns <code>-1</code> on error, <code>0</code> on success.</p>
<p>When you detach from the segment, it isn’t destroyed. Nor is it removed when <em>everyone</em> detaches from it. You have to specifically destroy it using a call to <code>shmctl()</code>, similar to the control calls for the other System V IPC functions:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb57-1"><a href="shm.html#cb57-1" aria-hidden="true" tabindex="-1"></a>shmctl<span class="op">(</span>shmid<span class="op">,</span> IPC_RMID<span class="op">,</span> NULL<span class="op">);</span></span></code></pre></div>
<p>The above call deletes the shared memory segment, assuming no one else is attached to it. The <code>shmctl()</code> function does a lot more than this, though, and is worth looking into. (On your own, of course, since this is only an overview!)</p>
<p>As always, you can destroy the shared memory segment from the command line using the <code>ipcrm</code> Unix command. Also, be sure that you don’t leave any unused shared memory segments sitting around wasting system resources. All the System V IPC objects you own can be viewed using the <code>ipcs</code> command.</p>
<h2 data-number="9.5" id="shmcon"><span class="header-section-number">9.5</span> Concurrency</h2>
<p>What are concurrency issues? Well, since you have multiple processes modifying the shared memory segment, it is possible that certain errors could crop up when updates to the segment occur simultaneously. This <em>concurrent</em> access is almost always a problem when you have multiple writers to a shared object.</p>
<p>The way to get around this is to use <a href="semaphores.html#semaphores">Semaphores</a> to lock the shared memory segment while a process is writing to it. (Sometimes the lock will encompass both a read and write to the shared memory, depending on what you’re doing.)</p>
<p>A true discussion of concurrency is beyond the scope of this paper, and you might want to check out the <a href="https://en.wikipedia.org/wiki/Concurrency">Wikipedia article on the matter</a><a href="references.html#fn38" class="footnote-ref" id="fnref38" role="doc-noteref"><sup>38</sup></a>. I’ll just leave it with this: if you start getting weird inconsistencies in your shared data when you connect two or more processes to it, you could very well have a concurrency problem.</p>
<h2 data-number="9.6" id="sample-code"><span class="header-section-number">9.6</span> Sample code</h2>
<p>Now that I’ve primed you on all the dangers of concurrent access to a shared memory segment without using semaphores, I’ll show you a demo that does just that. Since this isn’t a mission-critical application, and it’s unlikely that you’ll be accessing the shared data at the same time as any other process, I’ll just leave the semaphores out for the sake of simplicity.</p>
<p>This program does one of two things: if you run it with no command line parameters, it prints the contents of the shared memory segment. If you give it one command line parameter, it stores that parameter in the shared memory segment.</p>
<p>Here’s the code for <a href="https://beej.us/guide/bgipc/source/examples/shmdemo.c"><code>shmdemo.c</code></a><a href="references.html#fn39" class="footnote-ref" id="fnref39" role="doc-noteref"><sup>39</sup></a>:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="cb58-1"><a href="shm.html#cb58-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb58-2"><a href="shm.html#cb58-2"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb58-3"><a href="shm.html#cb58-3"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb58-4"><a href="shm.html#cb58-4"></a><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></span>
<span id="cb58-5"><a href="shm.html#cb58-5"></a><span class="pp">#include </span><span class="im">&lt;sys/ipc.h&gt;</span></span>
<span id="cb58-6"><a href="shm.html#cb58-6"></a><span class="pp">#include </span><span class="im">&lt;sys/shm.h&gt;</span></span>
<span id="cb58-7"><a href="shm.html#cb58-7"></a></span>
<span id="cb58-8"><a href="shm.html#cb58-8"></a><span class="pp">#define SHM_SIZE </span><span class="dv">1024</span><span class="pp">  </span><span class="co">/* make it a 1K shared memory segment */</span></span>
<span id="cb58-9"><a href="shm.html#cb58-9"></a></span>
<span id="cb58-10"><a href="shm.html#cb58-10"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span></span>
<span id="cb58-11"><a href="shm.html#cb58-11"></a><span class="op">{</span></span>
<span id="cb58-12"><a href="shm.html#cb58-12"></a>    key_t key<span class="op">;</span></span>
<span id="cb58-13"><a href="shm.html#cb58-13"></a>    <span class="dt">int</span> shmid<span class="op">;</span></span>
<span id="cb58-14"><a href="shm.html#cb58-14"></a>    <span class="dt">char</span> <span class="op">*</span>data<span class="op">;</span></span>
<span id="cb58-15"><a href="shm.html#cb58-15"></a>    <span class="dt">int</span> mode<span class="op">;</span></span>
<span id="cb58-16"><a href="shm.html#cb58-16"></a></span>
<span id="cb58-17"><a href="shm.html#cb58-17"></a>    <span class="cf">if</span> <span class="op">(</span>argc <span class="op">&gt;</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-18"><a href="shm.html#cb58-18"></a>            fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">&quot;usage: shmdemo [data_to_write]</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb58-19"><a href="shm.html#cb58-19"></a>            exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb58-20"><a href="shm.html#cb58-20"></a>    <span class="op">}</span></span>
<span id="cb58-21"><a href="shm.html#cb58-21"></a></span>
<span id="cb58-22"><a href="shm.html#cb58-22"></a>    <span class="co">/* make the key: */</span></span>
<span id="cb58-23"><a href="shm.html#cb58-23"></a>    <span class="cf">if</span> <span class="op">((</span>key <span class="op">=</span> ftok<span class="op">(</span><span class="st">&quot;shmdemo.c&quot;</span><span class="op">,</span> <span class="ch">&#39;R&#39;</span><span class="op">))</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-24"><a href="shm.html#cb58-24"></a>            perror<span class="op">(</span><span class="st">&quot;ftok&quot;</span><span class="op">);</span></span>
<span id="cb58-25"><a href="shm.html#cb58-25"></a>            exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb58-26"><a href="shm.html#cb58-26"></a>    <span class="op">}</span></span>
<span id="cb58-27"><a href="shm.html#cb58-27"></a></span>
<span id="cb58-28"><a href="shm.html#cb58-28"></a>    <span class="co">/* connect to (and possibly create) the segment: */</span></span>
<span id="cb58-29"><a href="shm.html#cb58-29"></a>    <span class="cf">if</span> <span class="op">((</span>shmid <span class="op">=</span> shmget<span class="op">(</span>key<span class="op">,</span> SHM_SIZE<span class="op">,</span> <span class="bn">0644</span> <span class="op">|</span> IPC_CREAT<span class="op">))</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-30"><a href="shm.html#cb58-30"></a>            perror<span class="op">(</span><span class="st">&quot;shmget&quot;</span><span class="op">);</span></span>
<span id="cb58-31"><a href="shm.html#cb58-31"></a>            exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb58-32"><a href="shm.html#cb58-32"></a>    <span class="op">}</span></span>
<span id="cb58-33"><a href="shm.html#cb58-33"></a></span>
<span id="cb58-34"><a href="shm.html#cb58-34"></a>    <span class="co">/* attach to the segment to get a pointer to it: */</span></span>
<span id="cb58-35"><a href="shm.html#cb58-35"></a>    data <span class="op">=</span> shmat<span class="op">(</span>shmid<span class="op">,</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb58-36"><a href="shm.html#cb58-36"></a></span>
<span id="cb58-37"><a href="shm.html#cb58-37"></a>    <span class="co">/* we _could_ use MAP_FAILED, but technically that&#39;s not */</span></span>
<span id="cb58-38"><a href="shm.html#cb58-38"></a>    <span class="co">/* the defined return value. System V failed on this one! */</span></span>
<span id="cb58-39"><a href="shm.html#cb58-39"></a>    <span class="cf">if</span> <span class="op">(</span>data <span class="op">==</span> <span class="op">(</span><span class="dt">void</span> <span class="op">*)(-</span><span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb58-40"><a href="shm.html#cb58-40"></a>            perror<span class="op">(</span><span class="st">&quot;shmat&quot;</span><span class="op">);</span></span>
<span id="cb58-41"><a href="shm.html#cb58-41"></a>            exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb58-42"><a href="shm.html#cb58-42"></a>    <span class="op">}</span></span>
<span id="cb58-43"><a href="shm.html#cb58-43"></a></span>
<span id="cb58-44"><a href="shm.html#cb58-44"></a>    <span class="co">/* read or modify the segment, based on the command line: */</span></span>
<span id="cb58-45"><a href="shm.html#cb58-45"></a>    <span class="cf">if</span> <span class="op">(</span>argc <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-46"><a href="shm.html#cb58-46"></a>            printf<span class="op">(</span><span class="st">&quot;writing to segment: </span><span class="sc">\&quot;%s\&quot;\n</span><span class="st">&quot;</span><span class="op">,</span> argv<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb58-47"><a href="shm.html#cb58-47"></a>            strncpy<span class="op">(</span>data<span class="op">,</span> argv<span class="op">[</span><span class="dv">1</span><span class="op">],</span> SHM_SIZE<span class="op">);</span></span>
<span id="cb58-48"><a href="shm.html#cb58-48"></a>            data<span class="op">[</span>SHM_SIZE<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">;</span></span>
<span id="cb58-49"><a href="shm.html#cb58-49"></a>    <span class="op">}</span> <span class="cf">else</span></span>
<span id="cb58-50"><a href="shm.html#cb58-50"></a>            printf<span class="op">(</span><span class="st">&quot;segment contains: </span><span class="sc">\&quot;%s\&quot;\n</span><span class="st">&quot;</span><span class="op">,</span> data<span class="op">);</span></span>
<span id="cb58-51"><a href="shm.html#cb58-51"></a></span>
<span id="cb58-52"><a href="shm.html#cb58-52"></a>    <span class="co">/* detach from the segment: */</span></span>
<span id="cb58-53"><a href="shm.html#cb58-53"></a>    <span class="cf">if</span> <span class="op">(</span>shmdt<span class="op">(</span>data<span class="op">)</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb58-54"><a href="shm.html#cb58-54"></a>            perror<span class="op">(</span><span class="st">&quot;shmdt&quot;</span><span class="op">);</span></span>
<span id="cb58-55"><a href="shm.html#cb58-55"></a>            exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb58-56"><a href="shm.html#cb58-56"></a>    <span class="op">}</span></span>
<span id="cb58-57"><a href="shm.html#cb58-57"></a></span>
<span id="cb58-58"><a href="shm.html#cb58-58"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb58-59"><a href="shm.html#cb58-59"></a><span class="op">}</span></span></code></pre></div>
<p>More commonly, a process will attach to the segment and run for a bit while other programs are changing and reading the shared segment. It’s neat to watch one process update the segment and see the changes appear to other processes. Again, for simplicity, the sample code doesn’t do that, but you can see how the data is shared between independent processes.</p>
<p>Also, there’s no code in here for removing the segment—be sure to do that when you’re done messing with it.</p>
<!-- BG_NEW_CHAPTER -->
<!-- Beej's guide to IPC

# vim: ts=4:sw=4:nosi:et:tw=72
-->
<!-- ======================================================= -->
<!-- Memory Mapped Files -->
<!-- ======================================================= -->
<hr><div style="text-align:center"><span><a href="semaphores.html" rel="prev">Prev</a> | </span><a href="index.html">Contents</a><span> | <a href="mmap.html" rel="next">Next</a></span></div></body>
</html>
